#ifndef PQRWMICRO_HH
#define PQRWMICRO_HH 1

#include <iostream>
#include <tamer/tamer.hh>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/resource.h>
#define DO_PERF 0
#if DO_PERF
#include <sys/prctl.h>
#include <sys/wait.h>
#endif
#include "json.hh"
#include "time.hh"

namespace pq {
static const char post_data[] = "She likes movie moby";

template <typename S>
class RwMicro {
  public:
    RwMicro(Json& param, S& server) 
        : prefresh_(param["prefresh"].as_i(10)), // percentage of refresh requests
          pactive_(param["pactive"].as_i(100)), // percentage of tweets being read
          nops_(param["nops"].as_i(100000)),
          nuser_(param["nusers"].as_i(1000)),
          nfollower_(param["nfollower"].as_i(100)), 
          npop_(param["popduration"].as_i(0)),
          postlen_(param["postlen"].as_i(20)),
          server_(server),
          push_(param["push"].as_b(true)),
          pprerefresh_(param["pprerefresh"].as_i(0)),
          client_push_(param["client_push"].as_b(false)),
          follower_(nuser_) {
    }
    tamed void safe_run();
  private:
    tamed inline void populate(tamer::event<> e);
    tamed inline void run(tamer::event<> e);
    tamed inline void post(uint32_t poster, size_t time, Str value, tamer::event<> e);

    int prefresh_;
    int pactive_;
    int nops_;
    int nuser_;
    int nfollower_;
    int npop_;
    int postlen_;
    S& server_;
    bool push_;
    int pprerefresh_;
    bool client_push_;
    std::vector<std::vector<uint32_t> > follower_;
};

tamed template <typename S>
void RwMicro<S>::post(uint32_t u, size_t time, Str value, tamer::event<> e) {
    tvars { 
        std::vector<uint32_t> follower;
        String s(value);
    }
    twait {
        server_.post(u, time, s, make_event()); 
        if (client_push_) {
            server_.prepare_push_post(u, time, s);
            for (auto& f : follower_[u])
                server_.push_post(f, make_event());
            // punish client_push_ with a get_follower RPC
            server_.get_follower(u, make_event(follower));
        }
    }
    e();
}

tamed template <typename S>
void RwMicro<S>::safe_run() {
    twait { this->populate(make_event()); }
    twait { this->run(make_event()); }
}

tamed template <typename S>
void RwMicro<S>::populate(tamer::event<> e) {
    tvars { size_t nread = 0, time = 1;
            int u, i, j;
            tamer::gather_rendezvous gr;
            bool *b;
    }
    srandom(1328);

    twait { server_.initialize(client_push_, !push_, 0, 0, nuser_, !push_, make_event()); }
    b = new bool[nuser_];
    for (u = 0; u < nuser_; ++u) {
        bzero(b, nuser_ * sizeof(*b));
        b[u] = true;
        for (j = 0; j < nfollower_; ++j) {
            int follower;
            while (b[follower = (random() % nuser_)]);
            b[follower] = true;
            follower_[u].push_back(follower);
            server_.subscribe(follower, u, gr.make_event());
            server_.add_follower(follower, u, gr.make_event());
            twait{ server_.pace(make_event()); }
        }
    }
    delete[] b;
    twait(gr);
    time = 1;
    if (npop_)
        for (i = 0; i < npop_; ++i) {
            post(random() % nuser_, ++time, String(post_data, postlen_), gr.make_event());
            twait { server_.pace(make_event()); }
        }
    else
        for (u = 0; u < nuser_; ++u)
            for (i = 0; i < 10; ++i) {
                post(u, ++time, String(post_data, postlen_), gr.make_event());
                twait { server_.pace(make_event()); }
            }
    twait(gr);
    if (pprerefresh_) {
        twait {
            for (int i = 0; i < nuser_ * pprerefresh_ / 100; ++i)
                server_.timeline_add_count(i, uint32_t(0), time, make_event(nread));
        }
    }
    std::cerr << "finished populating" << std::endl;
    e();
}

tamed template <typename S>
void RwMicro<S>::run(tamer::event<> e) {
    tvars {
        int time = 100000000, npost = 0, nrefresh = 0;
        size_t nread = 0;
        int* loadtime = new int[this->nuser_];
        double trefresh = 0;
        struct rusage ru[2];
        struct timeval tv[2];
        Json old_stats, stats;
        tamer::gather_rendezvous gr;
        const int nu_active = this->nuser_ * this->pactive_ / 100;
        int i = 0;
    }
    srandom(18181);
    bzero(loadtime, sizeof(*loadtime) * nuser_);
#if DO_PERF
    // perf profiling
    {
        String me(getpid());
        pid_t pid = fork();
        if (!pid) {
            prctl(PR_SET_PDEATHSIG, SIGINT);
            execlp("perf", "perf", "record", "-g", "-p", me.c_str(), NULL);
            exit(0);
        }
    }
#endif
    twait { server_.stats(make_event(old_stats)); }
    gettimeofday(&tv[0], NULL);
    getrusage(RUSAGE_SELF, &ru[0]);
    while (i < nops_) {
        if (random() % 100 < prefresh_) {
            int u = random() % nuser_;
            if (u >= nu_active) {
                ++i;
                continue;
            }
            struct timeval optv[2];
            gettimeofday(&optv[0], NULL);
            ++nrefresh;
            server_.timeline_scan_add_count(u, loadtime[u] + 1, time, gr.make_event(nread));
            loadtime[u] = time;
            gettimeofday(&optv[1], NULL);
            trefresh += to_real(optv[1] - optv[0]);
        } else {
            int poster = random() % nuser_;
            post(poster, ++time, String(post_data, postlen_), gr.make_event());
            ++npost;
        }
        twait { server_.pace(make_event()); }
        ++i;
    }
    twait(gr);
    getrusage(RUSAGE_SELF, &ru[1]);
    gettimeofday(&tv[1], NULL);
    twait { server_.stats(make_event(stats)); }
    if (stats.get("server_user_time")) {
        stats["server_user_time"] -= old_stats["server_user_time"];
        stats["server_system_time"] -= old_stats["server_system_time"];
        stats["server_validate_time"] -= old_stats["server_validate_time"];
        stats["server_insert_time"] -= old_stats["server_insert_time"];
        stats["server_other_time"] -= old_stats["server_other_time"];
    }
    stats = Json().set("inactive", 100 - pactive_)
        //.set("actual_post_read", nread * 100.0 / (std::max(npost, 1) * nfollower_))
        .set("expected_prefresh", prefresh_)
        .set("actual_prefresh", nrefresh * 100.0 / nops_)
        .set("nposts", npost)
        .set("total_ops", nops_)
	.set("nposts_read", nread)
        .set("nrefresh", nrefresh)
	.set("user_time", to_real(ru[1].ru_utime - ru[0].ru_utime))
        .set("system_time", to_real(ru[1].ru_stime - ru[0].ru_stime))
        .set("real_time", to_real(tv[1] - tv[0]))
        .set("refresh_time", trefresh)
        .merge(stats);
    std::cout << stats.unparse(Json::indent_depth(4)) << "\n";
    delete[] loadtime;
    e();
}

tamed void run_rwmicro_redis(Json& tp_param);
tamed void run_rwmicro_memcache(Json& tp_param);
tamed void run_rwmicro_pqremote(Json& tp_param, int client_port);


};

#endif
