// -*- mode: c++ -*-
#ifndef PQTWITTERNEW_SHIM_HH
#define PQTWITTERNEW_SHIM_HH

#include "json.hh"
#include "string.hh"
#include "pqremoteclient.hh"
#include <tamer/tamer.hh>
#include <map>

namespace pq {
using tamer::event;
using tamer::preevent;

#define TWEET_LENGTH 5

template <typename S, typename P>
class TwitterNewShim {
  public:
    TwitterNewShim(S& server, P& tp);

    typedef typename S::iterator iterator;
    typedef typename S::scan_result scan_result;

    tamed void initialize(tamer::event<> e);

    template <typename R>
    inline void subscribe(uint32_t subscriber, uint32_t poster, tamer::preevent<R> e);
    template <typename R>
    inline void mark_celebrity(uint32_t poster, tamer::preevent<R> done);
    template <typename R>
    inline void post(uint32_t poster, uint32_t time, const String& value, bool celeb, tamer::preevent<R> e);
    inline void prepare_push_post(uint32_t poster, uint32_t time, const String& value);
    template <typename R>
    inline void push_post(uint32_t subscriber, tamer::preevent<R> e);
    template <typename R>
    void timeline_scan(uint32_t subscriber,
                       uint32_t start_time, uint32_t end_time,
                       preevent<R, scan_result> e);
    template <typename R>
    void timeline_add_count(uint32_t subscriber,
                            uint32_t start_time, uint32_t end_time,
                            preevent<R, size_t> e);
    template <typename R>
    inline void follower_scan(uint32_t poster, tamer::preevent<R, scan_result> e);
    template <typename R>
    inline void post_scan(uint32_t poster, uint32_t beg_scan, uint32_t end_scan,
                          tamer::preevent<R, scan_result> e);

    template <typename R>
    inline void pace(tamer::preevent<R> done);
    template <typename R>
    inline void flush(tamer::preevent<R> done);
    tamed void update_progress(uint32_t prog, tamer::event<uint32_t> e);
    template <typename R>
    inline void stats(tamer::preevent<R, Json> e);
    template <typename R>
    inline void control(const Json& cmd, tamer::preevent<R, Json> e);

  private:
    S& server_;
    P& tp_;
    char buf_[256];
    String value_;
};


template <typename S, typename P>
class TwitterNewDBShim {
  public:
    typedef RemoteClient::iterator iterator;
    typedef RemoteClient::scan_result scan_result;

    TwitterNewDBShim(S& server, P& tp);

    tamed void initialize(tamer::event<> e);

    tamed void subscribe(uint32_t subscriber, uint32_t poster, tamer::event<> e);
    inline void mark_celebrity(uint32_t poster, tamer::event<> done);
    tamed void post(uint32_t poster, uint32_t time, const String& value, bool celeb, tamer::event<> e);
    inline void prepare_push_post(uint32_t poster, uint32_t time, const String& value);
    inline void push_post(uint32_t subscriber, tamer::event<> e);
    tamed void timeline_scan(uint32_t subscriber,
                       uint32_t start_time, uint32_t end_time,
                       event<scan_result> e);
    tamed void timeline_add_count(uint32_t subscriber,
                            uint32_t start_time, uint32_t end_time,
                            event<size_t> e);
    inline void follower_scan(uint32_t poster, tamer::event<scan_result> e);
    inline void post_scan(uint32_t poster, uint32_t beg_scan, uint32_t end_scan,
                          tamer::event<scan_result> e);
    inline void pace(tamer::event<> done);
    inline void flush(tamer::event<> done);
    inline void update_progress(uint32_t prog, tamer::event<uint32_t> done);
    tamed void stats(tamer::event<Json> e);
    inline void control(const Json& cmd, tamer::event<Json> e);

  private:
    S& server_;
    P& tp_;
    char buf_[256];
    String value_;
};


template <typename S, typename P>
class TwitterNewRedisShim {
  public:
    typedef RemoteClient::iterator iterator;
    typedef RemoteClient::scan_result scan_result;

    TwitterNewRedisShim(S& server, P& tp);

    template <typename R>
    inline void initialize(tamer::preevent<R> e);
    template <typename R>
    inline void subscribe(uint32_t subscriber, uint32_t poster, tamer::preevent<R> e);
    template <typename R>
    inline void mark_celebrity(uint32_t poster, tamer::preevent<R> done);
    template <typename R>
    inline void post(uint32_t poster, uint32_t time, const String& value, bool celeb, tamer::preevent<R> e);
    inline void prepare_push_post(uint32_t poster, uint32_t time, const String& value);
    template <typename R>
    inline void push_post(uint32_t subscriber, tamer::preevent<R> e);
    tamed void timeline_scan(uint32_t subscriber,
                             uint32_t start_time, uint32_t end_time,
                             event<scan_result> e);
    tamed void timeline_add_count(uint32_t subscriber,
                                  uint32_t start_time, uint32_t end_time,
                                  event<size_t> e);
    tamed void follower_scan(uint32_t poster, event<scan_result> e);
    tamed void post_scan(uint32_t poster, uint32_t beg_scan, uint32_t end_scan,
                         event<scan_result> e);
    template <typename R>
    inline void pace(tamer::preevent<R> done);
    template <typename R>
    inline void flush(tamer::preevent<R> done);
    tamed void update_progress(uint32_t prog, tamer::event<uint32_t> e);
    template <typename R>
    inline void stats(tamer::preevent<R, Json> e);
    template <typename R>
    inline void control(const Json& cmd, tamer::preevent<R, Json> e);

  private:
    S& server_;
    P& tp_;
    char buf_[256];
    String value_;
    uint32_t time_;
};


#define MEMCACHE_INLINE_TWEETS 1

template <typename S, typename P>
class TwitterNewMemcacheShim {
  public:
    typedef RemoteClient::iterator iterator;
    typedef RemoteClient::scan_result scan_result;

    TwitterNewMemcacheShim(S& server, P& tp);

    template <typename R>
    inline void initialize(tamer::preevent<R> e);
    tamed void subscribe(uint32_t subscriber, uint32_t poster, tamer::event<> e);
    template <typename R>
    inline void mark_celebrity(uint32_t poster, tamer::preevent<R> done);
    tamed void post(uint32_t poster, uint32_t time, const String& value,
                    bool celeb, tamer::event<> e);
    inline void prepare_push_post(uint32_t poster, uint32_t time, const String& value);
    template <typename R>
    inline void push_post(uint32_t subscriber, tamer::preevent<R> e);
    tamed void timeline_scan(uint32_t subscriber,
                             uint32_t start_time, uint32_t end_time,
                             event<scan_result> e);
    tamed void timeline_add_count(uint32_t subscriber,
                                  uint32_t start_time, uint32_t end_time,
                                  event<size_t> e);
    tamed void follower_scan(uint32_t poster, event<scan_result> e);
    tamed void post_scan(uint32_t poster, uint32_t beg_scan, uint32_t end_scan,
                         event<scan_result> e);
    tamed void stats(tamer::event<Json> e);
    template <typename R>
    inline void pace(tamer::preevent<R> done);
    template <typename R>
    inline void flush(tamer::preevent<R> done);
    tamed void update_progress(uint32_t prog, tamer::event<uint32_t> e);
    template <typename R>
    inline void control(const Json& cmd, tamer::preevent<R, Json> e);

  private:
    S& server_;
    P& tp_;
    char buf_[256];
    std::map<uint32_t, bool> inited_;
};


template <typename S, typename P>
TwitterNewShim<S,P>::TwitterNewShim(S& server, P& tp)
    : server_(server), tp_(tp) {
}

tamed template <typename S, typename P>
void TwitterNewShim<S,P>::initialize(tamer::event<> done) {
    tvars { Json j[4]; }
    if (tp_.push()) {
        twait {
            // The purpose of this join is to install triecuts for fairness
            server_.add_join("xxx|", "xxx}",
                             "xxx|<user>|<time>|<poster> = "
                             "copy p|<poster>|<time> "
                             "using s|<user>|<poster>, "
                             "t|<user>|<time>|<poster> " +
                             (tp_.subtables()
                                 ? String((tp_.binary()) ? "where user:4nt, time:4n, poster:4nt"
                                                         : "where user:8t, time:10, poster:8t")
                                 : String((tp_.binary()) ? "where user:4n, time:4n, poster:4n"
                                                         : "where user:8, time:10, poster:8")),
                             make_event(j[0]));
        }
    }
    else {
        twait {
            server_.add_join("t|", "t}",
                             "t|<user>|<time>|<poster> = " +
                             String((tp_.pull()) ? "pull " : "") +
                             "copy p|<poster>|<time> "
                             "using " + 
                             String((tp_.eager()) ? "eager " : "") +
                             "s|<user>|<poster> " +
                             (tp_.subtables()
                                 ? String((tp_.binary()) ? "where user:4nt, time:4n, poster:4nt"
                                                         : "where user:8t, time:10, poster:8t")
                                 : String((tp_.binary()) ? "where user:4n, time:4n, poster:4n"
                                                         : "where user:8, time:10, poster:8")),
                             make_event(j[0]));

            if (tp_.pull_celeb()) {
                server_.add_join("ct|", "ct}",
                                 "ct|<time>|<poster> = "
                                 "copy cp|<poster>|<time> " +
                                 String((tp_.binary()) ? "where poster:4n, time:4n"
                                                       : "where poster:8, time:10"),
                                 make_event(j[1]));

                server_.add_join("t|", "t}",
                                 "t|<user>|<time>|<poster> = "
                                 "pull copy ct|<time>|<poster> "
                                 "using s|<user>|<poster> " +
                                 (tp_.subtables()
                                     ? String((tp_.binary()) ? "where user:4nt, time:4n, poster:4n"
                                                             : "where user:8t, time:10, poster:8")
                                     : String((tp_.binary()) ? "where user:4n, time:4n, poster:4n"
                                                             : "where user:8, time:10, poster:8")),
                                 make_event(j[2]));

                // server_.add_join("cs|", "cs}",
                //                  "cs|<user>|<poster> = "
                //                  "copy c|<poster> "
                //                  "using s|<user>|<poster> " +
                //                  (tp_.subtables()
                //                      ? String((tp_.binary()) ? "where user:4nt, poster:4n"
                //                                              : "where user:8t, poster:10")
                //                      : String((tp_.binary()) ? "where user:4n, poster:4n"
                //                                              : "where user:8, poster:10")),
                //                  make_event(j[2]));
                // server_.add_join("t|", "t}",
                //                  "t|<user>|<time>|<poster> = "
                //                  "pull copy ct|<time>|<poster> "
                //                  "using filter cs|<user>|<poster> " +
                //                  (tp_.subtables()
                //                      ? String((tp_.binary()) ? "where user:4nt, time:4n, poster:4n"
                //                                              : "where user:8t, time:10, poster:8")
                //                      : String((tp_.binary()) ? "where user:4n, time:4n, poster:4n"
                //                                              : "where user:8, time:10, poster:8")),
                //                  make_event(j[3]));
            }
        }

        for (uint32_t i = 0; i < 4; ++i)
            if (j[i]["message"])
                std::cerr << "installing join: " << j[i] << "\n";
    }

    done();
}

template <typename S, typename P> template <typename R>
inline void TwitterNewShim<S,P>::subscribe(uint32_t subscriber, uint32_t poster, tamer::preevent<R> done) {
    if (tp_.binary()) {
        memcpy(buf_, "s|XXXX|XXXX", 11);
        write_in_net_order(buf_ + 2, subscriber);
        write_in_net_order(buf_ + 7, poster);
        if (tp_.writearound())
            server_.insert_db(Str(buf_, 11), Str("1", 1), std::move(done));
        else
            server_.insert(Str(buf_, 11), Str("1", 1), std::move(done));
    }
    else {
        sprintf(buf_, "s|%08u|%08u", subscriber, poster);
        if (tp_.writearound())
            server_.insert_db(Str(buf_, 19), Str("1", 1), std::move(done));
        else
            server_.insert(Str(buf_, 19), Str("1", 1), std::move(done));
    }
}

template <typename S, typename P> template <typename R>
inline void TwitterNewShim<S,P>::mark_celebrity(uint32_t poster, tamer::preevent<R> done) {
    if (tp_.binary()) {
        memcpy(buf_, "c|XXXX", 6);
        write_in_net_order(buf_ + 2, poster);
        if (tp_.writearound())
            server_.insert_db(Str(buf_, 6), Str("1", 1), std::move(done));
        else
            server_.insert(Str(buf_, 6), Str("1", 1), std::move(done));
    }
    else {
        sprintf(buf_, "c|%08u", poster);
        if (tp_.writearound())
            server_.insert_db(Str(buf_, 10), Str("1", 1), std::move(done));
        else
            server_.insert(Str(buf_, 10), Str("1", 1), std::move(done));
    }
}

template <typename S, typename P> template <typename R>
inline void TwitterNewShim<S,P>::post(uint32_t poster, uint32_t time, const String& value,
                                    bool celeb, tamer::preevent<R> done) {
    if (tp_.binary()) {
        memcpy(buf_, "cp|XXXX|XXXX", 11);
        write_in_net_order(buf_ + 3, poster);
        write_in_net_order(buf_ + 8, time);
        if (tp_.writearound())
            server_.insert_db(Str(buf_ + !celeb, 11 + celeb), value, std::move(done));
        else
            server_.insert(Str(buf_ + !celeb, 11 + celeb), value, std::move(done));
    }
    else {
        sprintf(buf_, "cp|%08u|%010u", poster, time);
        if (tp_.writearound())
            server_.insert_db(Str(buf_ + !celeb, 21 + celeb), value, std::move(done));
        else
            server_.insert(Str(buf_ + !celeb, 21 + celeb), value, std::move(done));
    }
}

template <typename S, typename P>
inline void TwitterNewShim<S,P>::prepare_push_post(uint32_t poster, uint32_t time,
                                              const String& value) {
    if (tp_.binary()) {
        memcpy(buf_, "t|XXXX|XXXX|XXXX", 16);
        write_in_net_order(buf_ + 7, time);
        write_in_net_order(buf_ + 12, poster);
    }
    else
        sprintf(buf_, "t|%08u|%010u|%08u", 0, time, poster);

    value_ = value;
}

template <typename S, typename P> template <typename R>
inline void TwitterNewShim<S,P>::push_post(uint32_t subscriber, tamer::preevent<R> done) {
    if (tp_.binary()) {
        write_in_net_order(buf_ + 2, subscriber);
        server_.insert(Str(buf_, 16), value_, std::move(done));
    }
    else {
        sprintf(buf_ + 2, "%08u", subscriber);
        buf_[10] = '|'; // replace terminating null
        server_.insert(Str(buf_, 30), value_, std::move(done));
    }
}

template <typename S, typename P> template <typename R>
inline void TwitterNewShim<S,P>::timeline_scan(uint32_t subscriber,
                                             uint32_t start_time, uint32_t end_time,
                                             tamer::preevent<R, scan_result> done) {

    if (tp_.binary()) {
        memcpy(buf_, "t|XXXX|XXXX t|XXXX} t|XXXX|XXXX", 31);
        write_in_net_order(buf_ + 2, subscriber);
        write_in_net_order(buf_ + 7, start_time);
        write_in_net_order(buf_ + 14, subscriber);
        write_in_net_order(buf_ + 22, subscriber);
        write_in_net_order(buf_ + 27, end_time);
        server_.scan(Str(buf_, 11), Str(buf_ + 12, 7), Str(buf_ + 20, 11), std::move(done));
    }
    else {
        sprintf(buf_, "t|%08u|%010u t|%08u} t|%08u|%010u",
                subscriber, start_time, subscriber, subscriber, end_time);
        server_.scan(Str(buf_, 21), Str(buf_ + 22, 11), Str(buf_ + 34, 21), std::move(done));
    }
}

template <typename S, typename P> template <typename R>
inline void TwitterNewShim<S,P>::timeline_add_count(uint32_t subscriber,
                                                  uint32_t start_time, uint32_t end_time,
                                                  tamer::preevent<R, size_t> done) {
    if (tp_.binary()) {
        memcpy(buf_, "t|XXXX|XXXX t|XXXX} t|XXXX|XXXX", 31);
        write_in_net_order(buf_ + 2, subscriber);
        write_in_net_order(buf_ + 7, start_time);
        write_in_net_order(buf_ + 14, subscriber);
        write_in_net_order(buf_ + 22, subscriber);
        write_in_net_order(buf_ + 27, end_time);
        server_.add_count(Str(buf_, 11), Str(buf_ + 12, 7), Str(buf_ + 20, 11), std::move(done));
    }
    else {
        sprintf(buf_, "t|%08u|%010u t|%08u} t|%08u|%010u",
                subscriber, start_time, subscriber, subscriber, end_time);
        server_.add_count(Str(buf_, 21), Str(buf_ + 22, 11), Str(buf_ + 34, 21), std::move(done));
    }
}

template <typename S, typename P> template <typename R>
inline void TwitterNewShim<S,P>::follower_scan(uint32_t poster,
                                             tamer::preevent<R, scan_result> done) {

    if (tp_.binary()) {
        memcpy(buf_, "s|XXXX s|XXXX}", 14);
        write_in_net_order(buf_ + 2, poster);
        write_in_net_order(buf_ + 9, poster);
        server_.scan(Str(buf_, 6), Str(buf_ + 7, 7), std::move(done));
    }
    else {
        sprintf(buf_, "s|%08u s|%08u}", poster, poster);
        server_.scan(Str(buf_, 10), Str(buf_ + 11, 11), std::move(done));
    }
}

template <typename S, typename P> template <typename R>
inline void TwitterNewShim<S,P>::post_scan(uint32_t poster,
                                         uint32_t start_time, uint32_t end_time,
                                         tamer::preevent<R, scan_result> done) {
    if (tp_.binary()) {
        memcpy(buf_, "p|XXXX|XXXX p|XXXX|XXXX", 23);
        write_in_net_order(buf_ + 2, poster);
        write_in_net_order(buf_ + 7, start_time);
        write_in_net_order(buf_ + 14, poster);
        write_in_net_order(buf_ + 19, end_time);
        server_.scan(Str(buf_, 11), Str(buf_ + 12, 11), std::move(done));
    }
    else {
        sprintf(buf_, "p|%08u|%010u p|%08u|%010u",
                poster, start_time, poster, end_time);
        server_.scan(Str(buf_, 21), Str(buf_ + 22, 21), std::move(done));
    }
}

template <typename S, typename P> template <typename R>
inline void TwitterNewShim<S,P>::pace(tamer::preevent<R> done) {
    server_.pace(std::move(done));
}

template <typename S, typename P> template <typename R>
inline void TwitterNewShim<S,P>::flush(tamer::preevent<R> done) {
    server_.flush(std::move(done));
}

tamed template <typename S, typename P>
void TwitterNewShim<S,P>::update_progress(uint32_t prog, tamer::event<uint32_t> done) {
    tvars {
        scan_result res;
        uint32_t slowest = prog;
    }

    sprintf(buf_, "prog|%03u", tp_.groupid());
    twait {
        server_.insert(Str(buf_, 8), String(prog), make_event());
        server_.scan("prog|", "prog}", make_event(res));
    }

    for (auto it = res.begin(); it != res.end(); ++it) {
        if (it->value().to_i() < slowest)
            slowest = it->value().to_i();
    }

    done(slowest);
}

template <typename S, typename P> template <typename R>
inline void TwitterNewShim<S,P>::stats(tamer::preevent<R, Json> done) {
    server_.stats(std::move(done));
}

template <typename S, typename P> template <typename R>
inline void TwitterNewShim<S,P>::control(const Json& cmd, tamer::preevent<R, Json> done) {
    server_.control(cmd, std::move(done));
}


template <typename S, typename P>
TwitterNewDBShim<S,P>::TwitterNewDBShim(S& server, P& tp)
    : server_(server), tp_(tp) {
}

tamed template <typename S, typename P>
void TwitterNewDBShim<S,P>::initialize(tamer::event<> done) {
    tvars { std::vector<String> statements({
        "SET session CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL READ COMMITTED",
        "PREPARE subscribe(int,int) AS "
            "INSERT INTO s SELECT $1,$2 WHERE NOT EXISTS (SELECT 1 FROM s WHERE usr = $1 AND poster = $2)",
        "PREPARE post(int,text,int) AS "
            "INSERT INTO p VALUES($1,$2,$3)",
        "PREPARE timeline_scan(int,int,int) AS "
             "SELECT t.usr, t.poster, t.value, t.time "
             "FROM t "
             "WHERE t.usr = $1 "
               "AND t.time >= $2 "
               "AND t.time < $3",
        "PREPARE timeline_add_count(int,int,int) AS "
             "SELECT COUNT(*) "
             "FROM t "
             "WHERE t.usr = $1 "
               "AND t.time >= $2 "
               "AND t.time < $3" }); }

    twait {
        server_.add_prepared(statements, make_event());
    }
    done();
}

tamed template <typename S, typename P>
void TwitterNewDBShim<S,P>::subscribe(uint32_t subscriber, uint32_t poster, tamer::event<> done) {
    tvars { Json j; }
    twait {
        server_.execute("EXECUTE subscribe(" + String(subscriber) + "," + String(poster) + ")", make_event(j));
    }
    done();
}

template <typename S, typename P>
inline void TwitterNewDBShim<S,P>::mark_celebrity(uint32_t poster, tamer::event<> done) {
    (void) poster;
    (void) done;
    mandatory_assert(false && "Function not supported in this mode.");
}

tamed template <typename S, typename P>
void TwitterNewDBShim<S,P>::post(uint32_t poster, uint32_t time, const String& value,
                                    bool celeb, tamer::event<> done) {
    tvars { Json j; }
    twait{
        server_.execute("EXECUTE post(" + String(poster) + ",'" + String(value) +  "'," + String(time) + ")", make_event(j));
    }
    done();
}

template <typename S, typename P>
inline void TwitterNewDBShim<S,P>::prepare_push_post(uint32_t poster, uint32_t time,
                                              const String& value) {
    (void) poster;
    (void) time;
    (void) value;
    mandatory_assert(false && "Function not supported in this mode.");
}

template <typename S, typename P>
inline void TwitterNewDBShim<S,P>::push_post(uint32_t subscriber, tamer::event<> done) {
    (void) subscriber;
    (void) done;
    mandatory_assert(false && "Function not supported in this mode.");
}

tamed template <typename S, typename P>
void TwitterNewDBShim<S,P>::timeline_scan(uint32_t subscriber,
                                             uint32_t start_time, uint32_t end_time,
                                             tamer::event<scan_result> done) {
    tvars { Json j, rj; }
    twait {
        server_.execute("EXECUTE timeline_scan(" + String(subscriber) + "," + String(start_time) +  "," + String(end_time) + ")", make_event(j));
    }
    std::vector<String> return_vector;
    for (auto it = j.abegin(); it < j.aend(); ++it ) {
        uint32_t usr = (*it)[0].to_i();
        uint32_t poster = (*it)[1].to_i();
        String value = (*it)[2].to_s();
        uint32_t time = (*it)[3].to_i();
            if (tp_.binary()) {
                memcpy(buf_, "t|XXXX|XXXX|XXXX", 16);
                write_in_net_order(buf_ + 2, usr);
                write_in_net_order(buf_ + 7, poster);
                write_in_net_order(buf_ + 12, time);
            } else {
                sprintf(buf_, "t|%08u|%010u|%08u",
                        usr, time, poster);
            }
            return_vector.push_back(buf_);
            return_vector.push_back(value);
    }
    done(scan_result(Json(return_vector)));
}

tamed template <typename S, typename P>
void TwitterNewDBShim<S,P>::timeline_add_count(uint32_t subscriber,
                                                  uint32_t start_time, uint32_t end_time,
                                                  tamer::event<size_t> done) {
    tvars { Json j; }
    twait {
        server_.execute("EXECUTE timeline_add_count(" + String(subscriber) + "," + String(start_time) +  "," + String(end_time) + ")", make_event(j));
    }
    auto count = j[0][0].to_i();
    done(count);
}

template <typename S, typename P>
inline void TwitterNewDBShim<S,P>::follower_scan(uint32_t poster,
                                             tamer::event<scan_result> done) {
    (void) poster;
    (void) done;
    mandatory_assert(false && "Function not supported in this mode.");
}

template <typename S, typename P>
inline void TwitterNewDBShim<S,P>::post_scan(uint32_t poster,
                                         uint32_t start_time, uint32_t end_time,
                                         tamer::event<scan_result> done) {
    (void) poster;
    (void) start_time;
    (void) end_time;
    (void) done;
    mandatory_assert(false && "Function not supported in this mode.");
}

template <typename S, typename P>
inline void TwitterNewDBShim<S,P>::pace(tamer::event<> done) {
    server_.maybe_flush();
    done();
}

template <typename S, typename P>
inline void TwitterNewDBShim<S,P>::update_progress(uint32_t prog,
                                                   tamer::event<uint32_t> done) {
    done(prog);
}

template <typename S, typename P>
inline void TwitterNewDBShim<S,P>::flush(tamer::event<> done) {
    server_.flush();
    done();
}

tamed template <typename S, typename P>
void TwitterNewDBShim<S,P>::stats(tamer::event<Json> done) {
    tvars { Json j, rj; }
    twait {
        server_.execute("SELECT s.*, p.*, t.* "
                        "FROM "
                            "(SELECT count(*) FROM p) p, "
                            "(SELECT count(*) FROM s) s, "
                            "(SELECT count(*) FROM t) t",
                        make_event(j));
    }

    uint32_t s_keys = 0;
    uint32_t p_keys = 0;
    uint32_t t_keys = 0;
    for (auto it = j.abegin(); it < j.aend(); ++it ) {
        s_keys = (*it)[0].to_i();
        p_keys = (*it)[1].to_i();
        t_keys = (*it)[2].to_i();
    }
    rj.set("tables", Json::make_array().push_back(Json().set("name", "p").set("store_size", p_keys))
                                       .push_back(Json().set("name", "s").set("store_size", s_keys))
                                       .push_back(Json().set("name", "t").set("store_size", t_keys)));
    done(rj);
}

template <typename S, typename P>
inline void TwitterNewDBShim<S,P>::control(const Json& cmd, tamer::event<Json> done) {
    (void) cmd;
    done(Json());
//    mandatory_assert(false && "Function not supported in this mode.");
}


template <typename S, typename P>
TwitterNewRedisShim<S,P>::TwitterNewRedisShim(S& server, P& tp)
    : server_(server), tp_(tp) {
}

template <typename S, typename P> template <typename R>
inline void TwitterNewRedisShim<S,P>::initialize(tamer::preevent<R> done) {
    done();
}

template <typename S, typename P> template <typename R>
inline void TwitterNewRedisShim<S,P>::subscribe(uint32_t subscriber, uint32_t poster, tamer::preevent<R> done) {
    if (tp_.binary()) {
        memcpy(buf_, "s|XXXX XXXX", 11);
        write_in_net_order(buf_ + 2, subscriber);
        write_in_net_order(buf_ + 7, poster);
        server_.sadd(Str(buf_, 6), Str(buf_ + 7, 4), std::move(done));
    }
    else {
        sprintf(buf_, "s|%08u %08u", subscriber, poster);
        server_.sadd(Str(buf_, 10), Str(buf_ + 11, 8), std::move(done));
    }
}

template <typename S, typename P> template <typename R>
inline void TwitterNewRedisShim<S,P>::mark_celebrity(uint32_t, tamer::preevent<R>) {
    mandatory_assert(false && "Unsupported by Redis shim.");
}

template <typename S, typename P> template <typename R>
inline void TwitterNewRedisShim<S,P>::post(uint32_t poster, uint32_t time, const String& value,
                                           bool, tamer::preevent<R> done) {
    if (tp_.binary()) {
        memcpy(buf_, "p|XXXX XXXX ", 12);
        memcpy(buf_ + 12, value.data(), value.length());
        write_in_net_order(buf_ + 2, poster);
        write_in_net_order(buf_ + 7, time);
        server_.zadd(Str(buf_, 6), Str(buf_ + 7, 5 + value.length()), time, std::move(done));
    }
    else {
        sprintf(buf_, "p|%08u %010u %s", poster, time, value.c_str());
        server_.zadd(Str(buf_, 10), Str(buf_ + 11, 11 + value.length()), time, std::move(done));
    }
}

template <typename S, typename P>
inline void TwitterNewRedisShim<S,P>::prepare_push_post(uint32_t poster, uint32_t time,
                                                        const String& value) {
    if (tp_.binary()) {
        memcpy(buf_, "t|XXXX XXXX|XXXX ", 17);
        memcpy(buf_ + 17, value.data(), value.length());
        write_in_net_order(buf_ + 7, time);
        write_in_net_order(buf_ + 12, poster);
    }
    else
        sprintf(buf_, "t|%08u %010u|%08u %s", 0, time, poster, value.c_str());

    value_ = value;
    time_ = time;
}

template <typename S, typename P> template <typename R>
inline void TwitterNewRedisShim<S,P>::push_post(uint32_t subscriber, tamer::preevent<R> done) {
    if (tp_.binary()) {
        write_in_net_order(buf_ + 2, subscriber);
        server_.zadd(Str(buf_, 6), Str(buf_ + 7, 10 + value_.length()), time_, std::move(done));
    }
    else {
        sprintf(buf_ + 2, "%08u", subscriber);
        server_.zadd(Str(buf_, 10), Str(buf_ + 11, 20 + value_.length()), time_, std::move(done));
    }
}

tamed template <typename S, typename P>
void TwitterNewRedisShim<S,P>::timeline_scan(uint32_t subscriber,
                                             uint32_t start_time, uint32_t end_time,
                                             event<scan_result> done) {
    tvars {
        typename S::result_set results;
        std::vector<String> ret;
        char buf[128];
        uint32_t prefixsz = (this->tp_.binary()) ? 6 : 10;
        uint32_t postersz = (this->tp_.binary()) ? 9 : 19;
    }

    if (tp_.binary()) {
        memcpy(buf, "t|XXXX|", 7);
        write_in_net_order(buf + 2, subscriber);
    }
    else
        sprintf(buf, "t|%08u|", subscriber);

    twait { server_.zrangebyscore(Str(buf, prefixsz), start_time, end_time, make_event(results)); }

    for (auto& t : results) {
        memcpy(buf + prefixsz + 1, t.data(), postersz);
        ret.push_back(buf);
        ret.push_back(Str(t.data() + postersz + 1, t.length() - postersz - 1));
    }

    done(scan_result(Json(ret)));
}

tamed template <typename S, typename P>
void TwitterNewRedisShim<S,P>::timeline_add_count(uint32_t subscriber,
                                                  uint32_t start_time, uint32_t end_time,
                                                  event<size_t> done) {
    tvars {
        typename S::result_set results;
        char buf[128];
        uint32_t prefixsz = (this->tp_.binary()) ? 6 : 10;
    }

    if (tp_.binary()) {
        memcpy(buf, "t|XXXX|", 7);
        write_in_net_order(buf + 2, subscriber);
    }
    else
        sprintf(buf, "t|%08u|", subscriber);

    twait { server_.zrangebyscore(Str(buf, prefixsz), start_time, end_time, make_event(results)); }

    done(done.result() + results.size());
}

tamed template <typename S, typename P>
void TwitterNewRedisShim<S,P>::follower_scan(uint32_t poster,
                                             event<scan_result> done) {
    tvars {
        typename S::result_set results;
        std::vector<String> ret;
        char buf[128];
        uint32_t prefixsz = (this->tp_.binary()) ? 6 : 10;
    }

    if (tp_.binary()) {
        memcpy(buf, "s|XXXX|", 7);
        write_in_net_order(buf + 2, poster);
    }
    else
        sprintf(buf, "s|%08u|", poster);

    twait { server_.smembers(Str(buf, prefixsz), make_event(results)); }

    for (auto& s : results) {
        memcpy(buf + prefixsz + 1, s.data(), s.length());
        ret.push_back(buf);
        ret.push_back("1");
    }

    done(scan_result(Json(ret)));
}

tamed template <typename S, typename P>
void TwitterNewRedisShim<S,P>::post_scan(uint32_t poster,
                                         uint32_t start_time, uint32_t end_time,
                                         event<scan_result> done) {
    tvars {
        typename S::result_set results;
        std::vector<String> ret;
        char buf[128];
        uint32_t prefixsz = (this->tp_.binary()) ? 6 : 10;
        uint32_t timesz = (this->tp_.binary()) ? 4 : 10;
    }

    if (tp_.binary()) {
        memcpy(buf, "p|XXXX|", 7);
        write_in_net_order(buf + 2, poster);
    }
    else
        sprintf(buf, "p|%08u|", poster);

    twait { server_.zrangebyscore(Str(buf, prefixsz), start_time, end_time, make_event(results)); }

    for (auto& t : results) {
        memcpy(buf + prefixsz + 1, t.data(), timesz);
        ret.push_back(buf);
        ret.push_back(Str(t.data() + timesz + 1, t.length() - timesz - 1));
    }

    done(scan_result(Json(ret)));
}

template <typename S, typename P> template <typename R>
inline void TwitterNewRedisShim<S,P>::pace(tamer::preevent<R> done) {
    server_.pace(std::move(done));
}

tamed template <typename S, typename P>
void TwitterNewRedisShim<S,P>::update_progress(uint32_t prog, tamer::event<uint32_t> done) {
    tvars {
        char buf[16];
        std::vector<String> res(this->tp_.ngroups());
        uint32_t slowest = prog;
    }

    sprintf(buf, "prog|%03u", tp_.groupid());

    twait {
        server_.set(Str(buf, 8), String(prog), make_event());
        for (uint32_t p = 0; p < tp_.ngroups(); ++p) {
            sprintf(buf, "prog|%03u", p);
            server_.get(Str(buf, 8), make_event(res[p]));
        }
    }

    for (auto r : res)
        if (!r.empty() && r.to_i() < slowest)
            slowest = r.to_i();

    done(slowest);
}

template <typename S, typename P> template <typename R>
inline void TwitterNewRedisShim<S,P>::flush(tamer::preevent<R> done) {
    done();
}

template <typename S, typename P> template <typename R>
inline void TwitterNewRedisShim<S,P>::stats(tamer::preevent<R, Json> done) {
    done(Json());
}

template <typename S, typename P> template <typename R>
inline void TwitterNewRedisShim<S,P>::control(const Json&, tamer::preevent<R, Json> done) {
    done(Json());
}


template <typename S, typename P>
TwitterNewMemcacheShim<S,P>::TwitterNewMemcacheShim(S& server, P& tp)
    : server_(server), tp_(tp) {
    mandatory_assert(tp_.push());
    mandatory_assert(!tp_.binary());
}

template <typename S, typename P> template <typename R>
inline void TwitterNewMemcacheShim<S,P>::initialize(tamer::preevent<R> done) {
    done();
}

tamed template <typename S, typename P>
void TwitterNewMemcacheShim<S,P>::subscribe(uint32_t subscriber, uint32_t poster,
                                            tamer::event<> done) {

    if (tp_.populate() && inited_.find(subscriber) == inited_.end()) {
        twait {
            uint32_t prefixsz = 10;
            inited_[subscriber] = true;

            sprintf(buf_, "s|%08u", subscriber);

            server_.set(Str(buf_, prefixsz), "", make_event());
            buf_[0] = 'p';
            server_.set(Str(buf_, prefixsz), "", make_event());
            buf_[0] = 't';
            server_.set(Str(buf_, prefixsz), "", make_event());
        }
    }

    sprintf(buf_, "s|%08u %08u", subscriber, poster);
    server_.append(Str(buf_, 10), Str(buf_ + 11, 8), done);
}

template <typename S, typename P> template <typename R>
inline void TwitterNewMemcacheShim<S,P>::mark_celebrity(uint32_t, tamer::preevent<R>) {
    mandatory_assert(false && "Unsupported by Memcache shim.");
}

#if MEMCACHE_INLINE_TWEETS

tamed template <typename S, typename P>
void TwitterNewMemcacheShim<S,P>::post(uint32_t poster, uint32_t time,
                                       const String& value,
                                       bool celeb, tamer::event<> done) {
    (void)celeb;
    sprintf(buf_, "p|%08u %010u|", poster, time);
    memcpy(buf_ + 22, value.data(), value.length());
    buf_[22 + value.length()] = '\0';

    server_.append(Str(buf_, 10), Str(buf_ + 11, 11 + TWEET_LENGTH), done);
}

template <typename S, typename P>
inline void TwitterNewMemcacheShim<S,P>::prepare_push_post(uint32_t poster, uint32_t time,
                                                           const String& value) {
    sprintf(buf_, "t|%08u %010u|%08u|", 0, time, poster);
    memcpy(buf_ + 31, value.data(), value.length());
    buf_[31 + value.length()] = '\0';
}

template <typename S, typename P> template <typename R>
inline void TwitterNewMemcacheShim<S,P>::push_post(uint32_t subscriber, tamer::preevent<R> done) {
    sprintf(buf_ + 2, "%08u", subscriber);
    server_.append(Str(buf_, 10), Str(buf_ + 11, 20 + TWEET_LENGTH), std::move(done));
}

tamed template <typename S, typename P>
void TwitterNewMemcacheShim<S,P>::timeline_scan(uint32_t subscriber,
                                                uint32_t start_time, uint32_t end_time,
                                                event<scan_result> done) {
    tvars {
        char tbuf[128];
        String timeline;
        uint32_t uidsz = 8;
        uint32_t timesz = 10;
        uint32_t prefixsz = uidsz + 2;
        uint32_t postsz = uidsz + timesz + 1;
        uint32_t entrysz = postsz + 1 + TWEET_LENGTH;
        std::vector<String> posts;
    }

    sprintf(tbuf, "t|%08u|", subscriber);

    twait { server_.get(Str(tbuf, prefixsz), make_event(timeline)); }

    uint32_t ptime;
    for (uint32_t t = 0; t < timeline.length() / entrysz; ++t) {
        const char* pstart = timeline.data() + t * entrysz;
        ptime = String(pstart, timesz).to_i();

        if (ptime >= start_time && ptime < end_time) {
            memcpy(tbuf + prefixsz + 1, pstart, postsz);

            posts.push_back(Str(tbuf, prefixsz + postsz + 1));
            posts.push_back(Str(pstart + postsz + 1, TWEET_LENGTH));
        }
    }

    done(scan_result(Json(posts)));
}

tamed template <typename S, typename P>
void TwitterNewMemcacheShim<S,P>::timeline_add_count(uint32_t subscriber,
                                                     uint32_t start_time, uint32_t end_time,
                                                     event<size_t> done) {
    tvars {
        char tbuf[128];
        String timeline;
        uint32_t prefixsz = 10;
        uint32_t entrysz = 20 + TWEET_LENGTH;
        size_t count = 0;
    }

    sprintf(tbuf, "t|%08u|", subscriber);

    twait { server_.get(Str(tbuf, prefixsz), make_event(timeline)); }

    uint32_t ptime;
    for (uint32_t t = 0; t < timeline.length() / entrysz; ++t) {
        const uint8_t* pstart = (const uint8_t*)timeline.data() + t * entrysz;
        ptime = String(pstart, 10).to_i();

        if (ptime >= start_time && ptime < end_time)
            ++count;
    }

    done(done.result() + count);
}

tamed template <typename S, typename P>
void TwitterNewMemcacheShim<S,P>::post_scan(uint32_t poster,
                                            uint32_t start_time, uint32_t end_time,
                                            event<scan_result> done) {
    tvars {
        char buf[128];
        String authored;
        uint32_t uidsz = 8;
        uint32_t timesz = 10;
        uint32_t prefixsz = uidsz + 2;
        uint32_t entrysz = timesz + 1 + TWEET_LENGTH;
        std::vector<String> posts;
    }

    sprintf(buf, "p|%08u|", poster);

    twait { server_.get(Str(buf, prefixsz), make_event(authored)); }

    uint32_t ptime;
    for (uint32_t t = 0; t < authored.length() / entrysz; ++t) {
        const char* pstart = authored.data() + t * entrysz;
        ptime = String(pstart, timesz).to_i();

        if (ptime >= start_time && ptime < end_time) {
            memcpy(buf + prefixsz + 1, pstart, timesz);

            posts.push_back(Str(buf, prefixsz + timesz + 1));
            posts.push_back(Str(pstart + timesz + 1, TWEET_LENGTH));
        }
    }

    done(scan_result(Json(posts)));
}

#else

tamed template <typename S, typename P>
void TwitterNewMemcacheShim<S,P>::post(uint32_t poster, uint32_t time,
                                       const String& value,
                                       bool celeb, tamer::event<> done) {
    (void)celeb;
    sprintf(buf_, "p|%08u|%010u|", poster, time);

    twait {
        server_.append(Str(buf_, 10), Str(buf_ + 11, 10), make_event());
        server_.set(Str(buf_, 21), value, make_event());
    }

    done();
}

template <typename S, typename P>
inline void TwitterNewMemcacheShim<S,P>::prepare_push_post(uint32_t poster, uint32_t time,
                                                           const String&) {
    sprintf(buf_, "t|%08u %010u|%08u|", 0, time, poster);
}

template <typename S, typename P> template <typename R>
inline void TwitterNewMemcacheShim<S,P>::push_post(uint32_t subscriber, tamer::preevent<R> done) {
    sprintf(buf_ + 2, "%08u", subscriber);
    server_.append(Str(buf_, 10), Str(buf_ + 11, 19), std::move(done));
}

tamed template <typename S, typename P>
void TwitterNewMemcacheShim<S,P>::timeline_scan(uint32_t subscriber,
                                                uint32_t start_time, uint32_t end_time,
                                                event<scan_result> done) {
    tvars {
        char tbuf[128];
        char pbuf[64];
        String timeline;
        uint32_t uidsz = 8;
        uint32_t timesz = 10;
        uint32_t prefixsz = uidsz + 2;
        uint32_t entrysz = uidsz + timesz + 1;
        std::vector<String> posts;
        std::vector<String*> values;
    }

    sprintf(tbuf, "t|%08u|", subscriber);
    sprintf(pbuf, "p|%08u|%010u", 0, 0);

    twait { server_.get(Str(tbuf, prefixsz), make_event(timeline)); }

    twait {
        uint32_t ptime;

        for (uint32_t t = 0; t < timeline.length() / entrysz; ++t) {
            const uint8_t* pstart = (const uint8_t*)timeline.data() + t * entrysz;
            ptime = String(pstart, timesz).to_i();

            if (ptime >= start_time && ptime < end_time) {
                memcpy(tbuf + prefixsz + 1, pstart, entrysz);
                memcpy(pbuf + 2, pstart + timesz + 1, uidsz);
                memcpy(pbuf + 3 + uidsz, pstart, timesz);

                values.push_back(new String());
                posts.push_back(Str(tbuf, prefixsz + entrysz + 1));
                posts.push_back("");

                server_.get(Str(pbuf, entrysz + 2), make_event(*values.back()));
            }
        }
    }

    for (uint32_t v = 0; v < values.size(); ++v) {
         posts[v * 2 + 1] = *values[v];
         delete values[v];
     }

    done(scan_result(Json(posts)));
}

tamed template <typename S, typename P>
void TwitterNewMemcacheShim<S,P>::timeline_add_count(uint32_t subscriber,
                                                     uint32_t start_time, uint32_t end_time,
                                                     event<size_t> done) {
    tvars {
        char tbuf[128];
        String timeline;
        uint32_t prefixsz = 10;
        uint32_t entrysz = 19;
        size_t count = 0;
    }

    sprintf(tbuf, "t|%08u|", subscriber);

    twait { server_.get(Str(tbuf, prefixsz), make_event(timeline)); }

    uint32_t ptime;

    for (uint32_t t = 0; t < timeline.length() / entrysz; ++t) {
        const uint8_t* pstart = (const uint8_t*)timeline.data() + t * entrysz;
        ptime = String(pstart, 10).to_i();

        if (ptime >= start_time && ptime < end_time)
            ++count;
    }

    done(done.result() + count);
}

tamed template <typename S, typename P>
void TwitterNewMemcacheShim<S,P>::post_scan(uint32_t poster,
                                            uint32_t start_time, uint32_t end_time,
                                            event<scan_result> done) {
    tvars {
        char buf[128];
        String authored;
        uint32_t uidsz = 8;
        uint32_t timesz = 10;
        uint32_t prefixsz = uidsz + 2;
        std::vector<String> posts;
        std::vector<String*> values;
    }

    sprintf(buf, "p|%08u|%010u", poster, 0);

    twait { server_.get(Str(buf, prefixsz), make_event(authored)); }

    twait {
        uint32_t ptime;

        for (uint32_t t = 0; t < authored.length() / timesz; ++t) {
            const uint8_t* pstart = (const uint8_t*)authored.data() + t * timesz;
            ptime = String(pstart, timesz).to_i();

            if (ptime >= start_time && ptime < end_time) {
                memcpy(buf + prefixsz + 1, pstart, timesz);

                values.push_back(new String());
                posts.push_back(Str(buf, prefixsz + timesz + 1));
                posts.push_back("");

                server_.get(Str(buf, prefixsz + timesz + 1), make_event(*values.back()));
            }
        }
    }

    for (uint32_t v = 0; v < values.size(); ++v) {
        posts[v * 2 + 1] = *values[v];
        delete values[v];
    }

    done(scan_result(Json(posts)));
}
#endif

tamed template <typename S, typename P>
void TwitterNewMemcacheShim<S,P>::follower_scan(uint32_t poster,
                                                event<scan_result> done) {
    tvars {
        char buf[128];
        String following;
        uint32_t prefixsz = 10;
        uint32_t entrysz = 8;
        std::vector<String> ret;
    }

    sprintf(buf, "s|%08u|", poster);

    twait { server_.get(Str(buf, prefixsz), make_event(following)); }

    for (uint32_t f = 0; f < following.length() / entrysz; ++f) {
        memcpy(buf + prefixsz + 1, following.data() + f * entrysz, entrysz);
        ret.push_back(Str(buf, prefixsz + entrysz + 1));
        ret.push_back("1");
    }

    done(scan_result(Json(ret)));
}

template <typename S, typename P> template <typename R>
inline void TwitterNewMemcacheShim<S,P>::pace(tamer::preevent<R> done) {
    server_.pace(std::move(done));
}

tamed template <typename S, typename P>
void TwitterNewMemcacheShim<S,P>::update_progress(uint32_t prog,
                                                  tamer::event<uint32_t> done) {
    tvars {
        char buf[16];
        std::vector<String> res(this->tp_.ngroups());
        uint32_t slowest = prog;
    }

    sprintf(buf, "prog|%03u", tp_.groupid());

    twait {
        server_.set(Str(buf, 8), String(prog), make_event());
        for (uint32_t p = 0; p < tp_.ngroups(); ++p) {
            sprintf(buf, "prog|%03u", p);
            server_.get(Str(buf, 8), make_event(res[p]));
        }
    }

    for (auto r : res)
        if (!r.empty() && r.to_i() < slowest)
            slowest = r.to_i();

    done(slowest);
}

template <typename S, typename P> template <typename R>
inline void TwitterNewMemcacheShim<S,P>::flush(tamer::preevent<R> done) {
    done();
}

tamed template <typename S, typename P>
void TwitterNewMemcacheShim<S,P>::stats(tamer::event<Json> done) {
    twait { server_.stats(make_event(done.result())); }

    Json& j = done.result();
    for (auto it = j.abegin(); it != j.aend(); ++it) {
        it->set("server_user_time", it->get("rusage_user").to_d());
        it->set("server_system_time", it->get("rusage_system").to_d());
        it->set("server_wall_time", it->get("uptime").to_d());
    }

    done.unblocker().trigger();
}

template <typename S, typename P> template <typename R>
inline void TwitterNewMemcacheShim<S,P>::control(const Json&, tamer::preevent<R, Json> done) {
    done(Json());
}

}

#endif
