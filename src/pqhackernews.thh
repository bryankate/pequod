#ifndef PQHACKERNEWS_HH
#define PQHACKERNEWS_HH
#include <boost/random.hpp>
#include <utility>
#include <vector>
#include <map>
#include <set>
#include <iostream>
#include <stdint.h>
#include <sys/resource.h>
#include <tamer/tamer.hh>
#include "json.hh"
#include "pqjoin.hh"
#include "json.hh"
#include "time.hh"
#include "sp_key.hh"
#include "hnpopulator.hh"
#include "hnshim.hh"
#include "pqremoteclient.hh"

namespace pq {
using tamer::event;
using tamer::preevent;

template <typename S>
class HackernewsRunner {
  public:
    HackernewsRunner(S& server, HackernewsPopulator& hp);
    tamed void populate();
    tamed void run();

  private:
    tamed void post_article(uint32_t author, uint32_t aid);
    tamed void post_comment(uint32_t commentor, uint32_t aid);
    tamed void vote(uint32_t voter, uint32_t aid);
    tamed void read_article(uint32_t aid);

    S& server_;
    HackernewsPopulator& hp_;
};

template <typename S>
inline HackernewsRunner<S>::HackernewsRunner(S& server, HackernewsPopulator& hp)
    : server_(server), hp_(hp) {
}

tamed template <typename S>
void HackernewsRunner<S>::post_article(uint32_t author, uint32_t aid) {
    hp_.post_article(author, aid);
    twait {
        server_.post_article(author, aid, Str("lalalalaxx", 10), hp_.karmas(), make_event());
    }
}

tamed template <typename S>
void HackernewsRunner<S>::post_comment(uint32_t commentor, uint32_t aid) {
    twait {
        server_.post_comment(commentor, hp_.articles()[aid], aid, hp_.next_comment(),
                             Str("calalalaxx", 10), make_event());
    }
}

tamed template <typename S>
void HackernewsRunner<S>::vote(uint32_t voter, uint32_t aid) {
    twait {
        server_.vote(voter, hp_.articles()[aid], aid, hp_.karmas(), make_event());
    }
}

tamed template <typename S>
void HackernewsRunner<S>::read_article(uint32_t aid) {
    mandatory_assert(aid < hp_.narticles());
    twait {
        server_.read_article(aid, hp_.articles()[aid], hp_.karmas(), hp_.check_karma(), tamer::event<>());
    }
}

tamed template <typename S>
void HackernewsRunner<S>::populate() {
    tvars {
        boost::mt19937 gen;
        boost::random_number_generator<boost::mt19937> rng(gen);
        uint32_t nv = 0, nc = 0;
    }
    twait { server_.initialize(hp_.log(), hp_.mk(), hp_.ma(), hp_.push(), tamer::event<>()); }

    if (hp_.run_only()) {
        printf("Not populating datastore\n");
        hp_.set_defaults();
        twait { server_.post_populate(make_event()); }
        return;
    }

    // Populate datastore
    if (hp_.pg()) {
        hp_.fill_db();
        if (!hp_.populate_only())
            hp_.populate_from_files(&nv, &nc);
    } else {
        gen.seed(13918);
        for (uint32_t aid = 0; aid < hp_.pre(); aid++) {
            const uint32_t author = rng(hp_.nusers());
            post_article(author, aid);
            const uint32_t ncomment = rng(20);
            for (uint32_t j = 1; j <= ncomment; ++j) {
                nc++;
                const uint32_t commentor = rng(hp_.nusers());
                post_comment(commentor, aid);
            }
            const uint32_t nvote = rng(50);
            for (uint32_t j = 0; j < nvote; ++j) {
                const uint32_t voter = rng(hp_.nusers());
                if (hp_.vote(aid, voter)) {
                    ++nv;
                    vote(voter, aid);
                }
            }
        }
    }

    if (hp_.log() && hp_.check_karma()) {
        std::cout << ": my karma table:\n";
        for (uint32_t i = 0; i < hp_.nusers(); i++)
            std::cout << " k " << i << ": " << hp_.karma(i) << "\n";
        std::cout << ": end my karma table\n";
    }

    twait { server_.post_populate(make_event()); }
    std::cout << "Added " << hp_.nusers() << " users, " << hp_.narticles() 
              << " articles, " << nv << " votes, " << nc << " comments." << std::endl;
}

tamed template <typename S>
void HackernewsRunner<S>::run() {
    tvars {
        boost::mt19937 gen;
        boost::random_number_generator<boost::mt19937> rng(gen);
        const uint32_t nops = this->hp_.nops();
        const uint32_t nusers = this->hp_.nusers();
        struct rusage ru[2];
        uint32_t nread = 0, npost = 0, ncomment = 0, nvote = 0;
        Json old_stats, stats;
        double start;
    }
    if (hp_.populate_only())
        return;
    gen.seed(13918);
    twait { server_.stats(make_event(old_stats)); }
    getrusage(RUSAGE_SELF, &ru[0]);
    twait { start = tstamp(); }
    for (uint32_t i = 0; i < nops; ++i) {
        uint32_t p = rng(100);
        uint32_t user = rng(nusers);
        if (p < hp_.post_rate()) {
            post_article(user, hp_.next_aid());
            npost++;
        } else {
            uint32_t aid = rng(hp_.narticles());
            read_article(aid);
            nread++;
            if (p < hp_.vote_rate() && hp_.vote(aid, user)) {
                vote(user, aid);
                ++nvote;
            }
            if (p < hp_.comment_rate()) {
                post_comment(user, aid);
                ncomment++;
            }
        }
    }
    getrusage(RUSAGE_SELF, &ru[1]);
    twait {
        server_.stats(make_event(stats));
    }
    if (stats.get("server_user_time")) {
        stats["server_user_time"] -= old_stats["server_user_time"];
        stats["server_system_time"] -= old_stats["server_system_time"];
    }
    stats = Json().set("nread", nread).set("npost", npost)
	.set("ncomment", ncomment).set("nvote", nvote)
	.set("time", to_real(ru[1].ru_utime - ru[0].ru_utime)).merge(stats);
    std::cout << stats.unparse(Json::indent_depth(4)) << "\n";
    double tm = (tstamp() - start) / 1000000;
    std::cout << nops << " done, " << tm << " seconds, " << nops/tm << " qps\n";
}

tamed void run_hn_remote(HackernewsPopulator& hp, int client_port) {
    tvars {
        tamer::fd fd;
        RemoteClient* rc;
        PQHackerNewsShim<RemoteClient>* shim;
        HackernewsRunner<PQHackerNewsShim<RemoteClient> >* hr;
    }
    std::cerr << "connecting to port " << client_port << "\n";
    twait { tamer::tcp_connect(in_addr{htonl(INADDR_LOOPBACK)}, client_port, make_event(fd)); }
    if (!fd) {
        std::cerr << "port " << client_port << ": "
                  << strerror(-fd.error()) << "\n";
        exit(1);
    }
    rc = new RemoteClient(fd);
    shim = new PQHackerNewsShim<RemoteClient>(*rc);
    hr = new HackernewsRunner<PQHackerNewsShim<RemoteClient> >(*shim, hp);
    //    twait { hr->populate(make_event()); }
    //    twait { hr->run(make_event()); }

    twait { hr->populate(); }
    twait { hr->run(); }
    delete hr;
    delete shim;
    delete rc;
}


};

#endif
