// -*- mode: c++ -*-
#ifndef PQTWITTER_NEW_HH
#define PQTWITTER_NEW_HH 1
#include <boost/random.hpp>
#include <utility>
#include <vector>
#include <set>
#include <iostream>
#include <stdint.h>
#include <tamer/tamer.hh>
#include <sys/resource.h>
#include "time.hh"
#include "json.hh"
#include "pqjoin.hh"
#include "pqserver.hh"

namespace pq {
using tamer::event;
using tamer::preevent;
class TwitterNewPopulator;

#define END_TIME        ((uint32_t)-1)
#define BASE_TIME       1000000000
#define LOGIN_WINDOW    100000
#define SKEW            1000
#define OVERLAP         0

struct TwitterUser {
  public:
    typedef std::set<uint32_t> fset;
    typedef std::vector<uint32_t> plist;

    TwitterUser(uint32_t uid);

    uint32_t nbackpost_;
    uint32_t npost_;
    uint32_t nsubscribe_;
    uint32_t nlogout_;
    uint32_t nlogin_;
    uint32_t ncheck_;
    size_t nread_;
    uint32_t last_read_;
    bool loggedin_;
    bool pending_;

    inline uint32_t uid() const { return uid_; }
    inline uint32_t celeb() const { return celeb_; }
    inline void mark_celeb() { celeb_ = true; }

    inline uint32_t nfollowers() const { return followers_.size(); }
    inline void add_follower(uint32_t f) { followers_.insert(f); }
    inline bool has_follower(uint32_t f) const { return followers_.find(f) != followers_.end(); }
    inline const fset& followers() const { return followers_; }

    inline void add_post(uint32_t time) { posts_.push_back(time); }
    inline const plist& posts() const { return posts_; }

    enum CompareField { comp_uid = 0, comp_nfollowers, comp_check, n_comp };

    struct Compare {
        Compare(CompareField field);
        inline bool operator() (const TwitterUser& a, const TwitterUser& b) const;
        inline bool operator() (const uint32_t& a, const TwitterUser& b) const;
        uint32_t field_;
    };

  private:
    uint32_t uid_;
    fset followers_;
    plist posts_;
    bool celeb_;
};

enum TwitterOp { op_post = 0, op_subscribe, op_login, op_logout, op_check, n_op };

class TwitterNewPopulator {
  public:
    typedef boost::mt19937 generator_type;
    typedef boost::random_number_generator<boost::mt19937> rng_type;
    typedef boost::random::discrete_distribution<> op_dist_type;
    typedef boost::random::discrete_distribution<> post_dist_type;
    typedef boost::random::uniform_int_distribution<> uni_dist_type;

    TwitterNewPopulator(const Json& param);

    inline uint32_t nusers() const { return nusers_; }
    inline uint32_t duration() const { return duration_; }
    inline uint32_t popduration() const { return popduration_; }
    inline uint32_t postlimit() const { return postlimit_; }
    inline double pct_active() const { return pct_active_; }
    inline bool push() const { return push_; }
    inline bool pull() const { return pull_; }
    inline bool pull_celeb() const { return celebthresh_; }
    inline bool fetch() const { return fetch_; }
    inline bool log() const { return log_; }
    inline bool synchronous() const { return synchronous_; }
    inline bool verbose() const { return verbose_; }

    inline TwitterUser& mutable_user(uint32_t user) { return users_[user]; }

    void make_subscriptions(generator_type& gen);
    void print_subscription_statistics(std::ostream& stream);
    void print_visualization();

    inline uint32_t rand_op(generator_type& gen) { return op_dist_(gen); }
    inline uint32_t rand_user(generator_type& gen) { return uni_dist_(gen); }
    inline uint32_t rand_user_post(generator_type& gen) { return post_dist_(gen); }

    static const char tweet_data[];

  private:
    uint32_t nusers_;
    uint32_t duration_;
    uint32_t popduration_;
    uint32_t postlimit_;
    bool push_;
    bool pull_;
    bool fetch_;
    bool log_;
    bool synchronous_;
    bool visualize_;
    bool verbose_;
    uint32_t celebthresh_;
    double pct_active_;
    String graph_file_;
    uint32_t min_followers_;
    uint32_t min_subs_;
    uint32_t max_subs_;
    uint32_t max_followers_;
    double shape_;

    std::vector<TwitterUser> users_;
    op_dist_type op_dist_;
    post_dist_type post_dist_;
    uni_dist_type uni_dist_;

    TwitterNewPopulator(const TwitterNewPopulator&) = delete;
    TwitterNewPopulator& operator=(const TwitterNewPopulator&) = delete;

    uint32_t* subscribe_probabilities(generator_type& gen);
    void import_subscriptions(generator_type& gen);
    void synthetic_subscriptions(generator_type& gen);
    void make_users(std::vector<std::pair<uint32_t, uint32_t>>& subs,
                    generator_type& gen);
};


template <typename S>
class TwitterNewShim {
  public:
    TwitterNewShim(S& server);

    template <typename R>
    inline void subscribe(uint32_t subscriber, uint32_t poster, tamer::preevent<R> e);
    template <typename R>
    inline void mark_celebrity(uint32_t poster, tamer::preevent<R> done);
    template <typename R>
    inline void post(uint32_t poster, uint32_t time, const String& value, bool celeb, tamer::preevent<R> e);
    tamed void initialize(bool push, bool pull, bool pull_celeb, tamer::event<> e);
    inline void prepare_push_post(uint32_t poster, uint32_t time, const String& value);
    template <typename R>
    inline void push_post(uint32_t subscriber, tamer::preevent<R> e);
    typedef typename S::scan_result scan_result;
    tamed void timeline_scan(TwitterUser* user,
                             uint32_t start_time, uint32_t end_time,
                             uint32_t& npending, tamer::event<>& trigger, bool log,
                             tamer::event<> e);
    template <typename R>
    inline void follower_scan(uint32_t poster, tamer::preevent<R, scan_result> e);
    template <typename R>
    inline void post_scan(uint32_t poster, uint32_t beg_scan, uint32_t end_scan,
                          tamer::preevent<R, scan_result> e);
    template <typename R>
    inline void pace(tamer::preevent<R> done);
    template <typename R>
    inline void stats(tamer::preevent<R, Json> e);
    template <typename R>
    inline void control(const Json& cmd, tamer::preevent<R> e);

  private:
    S& server_;
    char buf_[key_capacity];
    String value_;
};

template <typename S>
TwitterNewShim<S>::TwitterNewShim(S& server)
    : server_(server) {
}

tamed template <typename S>
void TwitterNewShim<S>::initialize(bool push, bool pull, bool pull_celeb,
                                   tamer::event<> done) {
    tvars { Json j[4]; }
    if (push) {
        twait {
            // The purpose of this join is to install triecuts for fairness
            server_.add_join("xxx|", "xxx}",
                             "xxx|<user>|<time>|<poster> = "
                             "copy p|<poster>|<time> "
                             "using s|<user>|<poster>, "
                             "t|<user>|<time>|<poster> pull "
                             "where user:4nt, time:4n, poster:4nt",
                             make_event(j[0]));
        }
    }
    else {
        twait {
            server_.add_join("t|", "t}",
                             "t|<user>|<time>|<poster> = "
                             "copy p|<poster>|<time> " +
                             String((pull) ? "pull " : "") +
                             "using s|<user>|<poster> "
                             "where user:4nt, time:4n, poster:4nt",
                             make_event(j[0]));

            if (pull_celeb) {
                server_.add_join("ct|", "ct}",
                                 "ct|<time>|<poster> = "
                                 "copy cp|<poster>|<time> "
                                 "where poster:4n, time:4n",
                                 make_event(j[3]));
                server_.add_join("cs|", "cs}",
                                 "cs|<user>|<poster> = "
                                 "copy c|<poster> "
                                 "using s|<user>|<poster> "
                                 "where user:4n, poster:4n",
                                 make_event(j[2]));
                server_.add_join("t|", "t}",
                                 "t|<user>|<time>|<poster> = "
                                 "pull copy ct|<time>|<poster> "
                                 "using filter cs|<user>|<poster> "
                                 "where user:4n, time:4n, poster:4n",
                                 make_event(j[1]));
            }
        }

        for (uint32_t i = 0; i < 4; ++i)
            if (j[i]["message"])
                std::cerr << "installing join: " << j[i] << "\n";
    }

    done();
}

template <typename S> template <typename R>
inline void TwitterNewShim<S>::subscribe(uint32_t subscriber, uint32_t poster, tamer::preevent<R> done) {
    memcpy(buf_, "s|XXXX|XXXX", 11);
    write_in_net_order(buf_ + 2, subscriber);
    write_in_net_order(buf_ + 7, poster);
    server_.insert(Str(buf_, 11), Str("1", 1), done);
}

template <typename S> template <typename R>
inline void TwitterNewShim<S>::mark_celebrity(uint32_t poster, tamer::preevent<R> done) {
    memcpy(buf_, "c|XXXX", 6);
    write_in_net_order(buf_ + 2, poster);
    server_.insert(Str(buf_, 6), Str("1", 1), done);
}

template <typename S> template <typename R>
inline void TwitterNewShim<S>::post(uint32_t poster, uint32_t time, const String& value,
                                    bool celeb, tamer::preevent<R> done) {
    memcpy(buf_, "cp|XXXX|XXXX", 11);
    write_in_net_order(buf_ + 3, poster);
    write_in_net_order(buf_ + 8, time);
    server_.insert(Str(buf_ + !celeb, 11 + celeb), value, done);
}

template <typename S>
inline void TwitterNewShim<S>::prepare_push_post(uint32_t poster, uint32_t time,
                                              const String& value) {
    memcpy(buf_, "t|XXXX|XXXX|XXXX", 16);
    write_in_net_order(buf_ + 7, time);
    write_in_net_order(buf_ + 12, poster);
    value_ = value;
}

template <typename S> template <typename R>
inline void TwitterNewShim<S>::push_post(uint32_t subscriber, tamer::preevent<R> done) {
    write_in_net_order(buf_ + 2, subscriber);
    server_.insert(Str(buf_, 16), value_, done);
}

tamed template <typename S>
void TwitterNewShim<S>::timeline_scan(TwitterUser* user,
                                            uint32_t start_time, uint32_t end_time,
                                            uint32_t& npending, tamer::event<>& trigger,
                                            bool log, tamer::event<> done) {
    tvars {
        typename S::scan_result sr;
    }

    memcpy(buf_, "t|XXXX|XXXX t|XXXX|XXXX", 23);
    write_in_net_order(buf_ + 2, user->uid());
    write_in_net_order(buf_ + 7, start_time);
    write_in_net_order(buf_ + 14, user->uid());
    write_in_net_order(buf_ + 19, end_time);

    twait { server_.scan(Str(buf_, 11), Str(buf_ + 12, 11), make_event(sr)); }

    if (log) {
        fprintf(stderr, "scan [t|%08u|%010u, t|%08u|%010u)\n",
                user->uid(), start_time, user->uid(), end_time);

        for (auto it = sr.begin(); it != sr.end(); ++it) {
            assert(it->key().length() == 16);
            assert(it->key()[0] == 't');
            std::cerr << "  t|" << read_in_net_order<uint32_t>(it->key().data() + 2)
                      << "|" << read_in_net_order<uint32_t>(it->key().data() + 7)
                      << "|" << read_in_net_order<uint32_t>(it->key().data() + 12)
                      << ": " << it->value() << "\n";
        }
    }

    // extract timestamp of last post read
    if (sr.size()) {
        typename S::iterator it = sr.begin();
        for (uint32_t i = 0; i < sr.size() - 1; ++i)
            ++it;
        uint32_t last = read_in_net_order<uint32_t>(it->key().data() + 7);
        if (last > user->last_read_)
            user->last_read_ = last;
    }

    --npending;
    user->pending_ = false;
    user->nread_ += sr.size();

    trigger.trigger();
    done();
}

template <typename S> template <typename R>
inline void TwitterNewShim<S>::follower_scan(uint32_t poster,
                                             tamer::preevent<R, scan_result> done) {
    memcpy(buf_, "s|XXXX s|XXXX}", 14);
    write_in_net_order(buf_ + 2, poster);
    write_in_net_order(buf_ + 9, poster);
    server_.scan(Str(buf_, 6), Str(buf_ + 7, 7), done);
}

template <typename S> template <typename R>
inline void TwitterNewShim<S>::post_scan(uint32_t poster,
                                         uint32_t start_time, uint32_t end_time,
                                         tamer::preevent<R, scan_result> done) {
    memcpy(buf_, "p|XXXX|XXXX p|XXXX|XXXX", 23);
    write_in_net_order(buf_ + 2, poster);
    write_in_net_order(buf_ + 7, start_time);
    write_in_net_order(buf_ + 14, poster);
    write_in_net_order(buf_ + 19, end_time);
    server_.scan(Str(buf_, 11), Str(buf_ + 12, 11), done);
}

template <typename S> template <typename R>
inline void TwitterNewShim<S>::pace(tamer::preevent<R> done) {
    server_.pace(done);
}

template <typename S> template <typename R>
inline void TwitterNewShim<S>::stats(tamer::preevent<R, Json> done) {
    server_.stats(done);
}

template <typename S> template <typename R>
inline void TwitterNewShim<S>::control(const Json& cmd, tamer::preevent<R> done) {
    server_.control(cmd, done);
}

template <typename S>
class TwitterNewRunner {
  public:
    TwitterNewRunner(S& server, TwitterNewPopulator& tp);

    tamed void populate(tamer::event<> done);
    tamed void run(tamer::event<> done);

  private:
    S& server_;
    TwitterNewPopulator& tp_;
    uint32_t currtime_;
    uint32_t pending_;
    tamer::event<> trigger_;

    template <typename R>
    void subscribe(uint32_t s, uint32_t p, uint32_t time, preevent<R> e);
    tamed void post(uint32_t u, uint32_t time, Str value, event<> e);
    tamed void backfill(uint32_t u, uint32_t f, uint32_t time, event<> e);
};

template <typename S>
inline TwitterNewRunner<S>::TwitterNewRunner(S& server, TwitterNewPopulator& tp)
    : server_(server), tp_(tp), currtime_(BASE_TIME), pending_(0) {
}

template <typename S> template <typename R>
void TwitterNewRunner<S>::subscribe(uint32_t subscriber, uint32_t poster,
                                    uint32_t time, preevent<R> e) {
    if (tp_.log())
        fprintf(stderr, "%d: subscribe s|%08d|%08d\n", time, subscriber, poster);

    // in client push mode we reverse the subscriber key to make followers list
    server_.subscribe((tp_.push()) ? poster : subscriber,
                      (tp_.push()) ? subscriber : poster,
                      e);
}

tamed template <typename S>
void TwitterNewRunner<S>::post(uint32_t u, uint32_t time, Str value, event<> e) {
    tvars {
        char buf[128];
        typename S::scan_result scan_result;
        TwitterUser* user;
    }

    if (tp_.log())
        fprintf(stderr, "%d: post p|%08d|%010d\n", time, u, time);

    user = &tp_.mutable_user(u);
    user->add_post(time);

    twait {
        server_.post(u, time, value, user->celeb(), make_event());

        if (tp_.push()) {
            server_.prepare_push_post(u, time, value);

            for (auto f = user->followers().begin(); f != user->followers().end(); ++f)
                server_.push_post(*f, make_event());

            // we only do the follower scan for fairness.
            server_.follower_scan(u, make_event(scan_result));
        }
    }
    e();
}

tamed template <typename S>
void TwitterNewRunner<S>::backfill(uint32_t u, uint32_t f, uint32_t time, event<> e) {
    assert(tp_.push());

    tvars { char buf[128];
            uint32_t beg_scan = time - LOGIN_WINDOW;
            typename S::scan_result scan_result;
            TwitterUser* poster;
    }

    poster = &tp_.mutable_user(f);

    twait {
        for (auto p = poster->posts().rbegin(); p != poster->posts().rend(); ++p) {
            if (*p < beg_scan)
                break;

            server_.prepare_push_post(f, *p, String(TwitterNewPopulator::tweet_data, 5));
            server_.push_post(u, make_event());
            ++poster->nbackpost_;
        }

        // do the post scan for fairness.
        server_.post_scan(f, beg_scan, END_TIME, make_event(scan_result));
    }
    e();
}

tamed template <typename S>
void TwitterNewRunner<S>::populate(tamer::event<> done) {
    tvars { boost::mt19937 gen;
            uint32_t nusers;
            uint32_t post_end_time;
            uint32_t u;
            TwitterUser* user;
            tamer::gather_rendezvous gr;
    }
    gen.seed(112181);

    if (tp_.verbose()) { std::cerr << "Creating social graph." << std::endl; }
    tp_.make_subscriptions(gen);
    tp_.print_subscription_statistics(std::cerr);

    // need to assign this here because make_subscriptions
    // can update tp_.nusers_ (when loaded from a file)
    nusers = tp_.nusers();
    post_end_time = this->currtime_ + tp_.popduration();

    twait {
        if (tp_.verbose()) { std::cerr << "Building subscription table." << std::endl; }
        for (u = 0; u < nusers; ++u) {
            user = &tp_.mutable_user(u);

            for (auto f = user->followers().begin(); f != user->followers().end(); ++f)
                subscribe(*f, u, currtime_, make_event());

            if (user->celeb())
                server_.mark_celebrity(u, make_event());
        }
    }

    if (tp_.verbose()) { std::cerr << "Populating twittersphere." << std::endl; }
    while(currtime_ < post_end_time) {
        u = tp_.rand_user_post(gen);
        post(u, currtime_, String(TwitterNewPopulator::tweet_data, 5), gr.make_event());
        ++currtime_;

        twait{ server_.pace(make_event()); }
    }
    twait(gr);

    twait { server_.initialize(tp_.push(), tp_.pull(), tp_.pull_celeb(), make_event()); }
    done();
}

tamed template <typename S>
void TwitterNewRunner<S>::run(tamer::event<> done) {
    tvars {
        boost::mt19937 gen;
        boost::uniform_real<> active_rng(0,100);
        struct rusage ru[2];
        struct timeval tv[2];
        uint32_t nusers = this->tp_.nusers();
        uint32_t beg_time = this->currtime_;
        uint32_t end_time = beg_time + this->tp_.duration();
        uint32_t u, beg_scan, end_scan, slot;
        uint32_t postlimit = this->tp_.postlimit();
        size_t dummy = 0, nfull = 0, nop_post = 0;
        std::vector<uint32_t> active;
        std::vector<uint32_t> loggedin;
        TwitterUser* user = NULL;
        typename S::scan_result scan_result;
        Json old_stats, stats;
        tamer::gather_rendezvous gr;
    }
    gen.seed(13918);

    // create a working set of already logged in users
    for (u = 0; u < nusers; ++u) {
        if (active_rng(gen) >= tp_.pct_active())
            continue;

        user = &tp_.mutable_user(u);
        ++pending_;

        server_.timeline_scan(user, 0, END_TIME, pending_, trigger_, tp_.log(), gr.make_event());
        twait{ server_.pace(make_event()); }

        user->nread_ = 0;
        user->loggedin_ = true;
        loggedin.push_back(u);
    }
    twait(gr);
    assert(!pending_);

    if (loggedin.empty() && tp_.pct_active() > 0)
        assert(false && "There were no active users selected.");

    twait { server_.stats(make_event(old_stats)); }

    if (tp_.verbose()) { std::cerr << "Starting workload." << std::endl; }
    getrusage(RUSAGE_SELF, &ru[0]);
    gettimeofday(&tv[0], 0);

    while (currtime_ < end_time && ((postlimit) ? (nop_post < postlimit) : true)) {
        user = NULL;

        switch(tp_.rand_op(gen)) {
            case op_post:
                user = &tp_.mutable_user(tp_.rand_user_post(gen));
                post(user->uid(), currtime_,
                     String(TwitterNewPopulator::tweet_data, 5), gr.make_event());

                ++user->npost_;
                ++nop_post;
                break;

            case op_subscribe:
                user = &tp_.mutable_user(tp_.rand_user(gen));
                uint32_t following;

                do {
                    following = tp_.rand_user(gen);
                } while (following == user->uid() ||
                         tp_.mutable_user(following).has_follower(user->uid()));

                tp_.mutable_user(following).add_follower(user->uid());
                subscribe(user->uid(), following, currtime_, gr.make_event());
                ++user->nsubscribe_;

                if (tp_.push())
                    backfill(u, following, currtime_, gr.make_event());
                break;

            case op_logout:
                if (loggedin.empty() || (pending_ == loggedin.size()))
                    break;

                do {
                    slot = gen() % loggedin.size();
                    user = &tp_.mutable_user(loggedin[slot]);
                } while(user->pending_);

                if (tp_.log())
                    fprintf(stderr, "%d: logout %08d\n", currtime_, user->uid());

                active.push_back(user->uid());
                loggedin.erase(loggedin.begin() + slot);
                user->last_read_ = 0;
                user->loggedin_ = false;
                ++user->nlogout_;
                break;

            case op_login:
                do_login:
                if (!active.empty()) {
                    slot = gen() % active.size();
                    user = &tp_.mutable_user(active[slot]);
                    active.erase(active.begin() + slot);

                    if (tp_.log())
                        fprintf(stderr, "%d: login %08d\n", currtime_, user->uid());

                    loggedin.push_back(user->uid());
                    user->loggedin_ = true;
                    ++user->nlogin_;
                }
                // fall through to check timeline after login

            case op_check:
                if (!user) {
                    do_check:
                    if (!loggedin.empty() && (pending_ < loggedin.size())) {
                        do {
                            user = &tp_.mutable_user(loggedin[gen() % loggedin.size()]);
                        } while (user->pending_);
                    }
                    else if (!active.empty())
                        goto do_login;
                    else {
                        // wait until there is a loggedin user that is not
                        // already refreshing its timeline
                        twait { trigger_ = make_event(); }
                        goto do_check;
                    }
                }

                beg_scan = user->last_read_;
                end_scan = currtime_ - SKEW;

                if (!beg_scan) {
                    beg_scan = currtime_ - LOGIN_WINDOW;
                    ++nfull;
                }
                else
                    beg_scan -= OVERLAP;

                user->pending_ = true;
                ++pending_;

                server_.timeline_scan(user, beg_scan, end_scan,
                                      pending_, trigger_, tp_.log(),
                                      gr.make_event());

                if (tp_.synchronous())
                    twait(gr);
                else
                    twait { server_.pace(make_event()); }

                ++user->ncheck_;
                break;

            default:
                assert(false && "Unknown operation.");
        }

        ++currtime_;

        if (tp_.verbose()) {
            uint32_t diff = currtime_ - beg_time;
            if (currtime_ > beg_time && diff % (tp_.duration() / 10) == 0)
                std::cerr << diff / (tp_.duration() / 10) * 10 << "% complete" << std::endl;
        }
    }
    twait(gr);

    // do a final scan for every loggedin user. this helps to ensure that
    // each distributed experiment does roughly the same amount of work
    // despite differences in rpc ordering
    if (tp_.verbose()) { std::cerr << "Final scan." << std::endl; }
    for (uint32_t u : loggedin) {
        user = &tp_.mutable_user(u);
        server_.timeline_scan(user, user->last_read_, END_TIME,
                              pending_, trigger_, tp_.log(), gr.make_event());
    }
    twait(gr);

    getrusage(RUSAGE_SELF, &ru[1]);
    gettimeofday(&tv[1], 0);

    twait { server_.stats(make_event(stats)); }
    //twait { server_.control(Json().set("print_table_keys", "p|"), make_event()); }

    uint32_t nbackpost = 0, npost = 0, nsubscribe = 0,
             nlogout = 0, nlogin = 0, ncheck = 0, nread = 0;

    for (u = 0; u < nusers; ++u) {
        nbackpost += tp_.mutable_user(u).nbackpost_;
        npost += tp_.mutable_user(u).npost_;
        nsubscribe += tp_.mutable_user(u).nsubscribe_;
        nlogout += tp_.mutable_user(u).nlogout_;
        nlogin += tp_.mutable_user(u).nlogin_;
        ncheck += tp_.mutable_user(u).ncheck_;
        nread += tp_.mutable_user(u).nread_;
    }

    if (!stats.is_array()) {
        old_stats = Json::make_array(old_stats);
        stats = Json::make_array(stats);
    }

    uint32_t s = 0;
    for (auto it = stats.abegin(); it != stats.aend(); ++it, ++s)
        if (it->get("server_user_time")) {
            (*it)["server_user_time"] -= old_stats[s]["server_user_time"];
            (*it)["server_system_time"] -= old_stats[s]["server_system_time"];
        }
    stats = Json().set("servers", stats);

    stats.set("nposts", npost)
         .set("nbackposts", nbackpost)
         .set("nsubscribes", nsubscribe)
         .set("nchecks", ncheck)
         .set("nfull", nfull)
         .set("nposts_read", nread)
         .set("nactive", active.size() + loggedin.size())
         .set("nlogins", nlogin)
         .set("nlogouts", nlogout)
         .set("user_time", to_real(ru[1].ru_utime - ru[0].ru_utime))
         .set("system_time", to_real(ru[1].ru_stime - ru[0].ru_stime))
         .set("real_time", to_real(tv[1] - tv[0]));
    std::cout << stats.unparse(Json::indent_depth(4)) << "\n";

    tp_.print_visualization();
    done();
}

tamed void run_twitter_new_remote(TwitterNewPopulator& tp, int client_port,
                                  const Hosts* hosts, const Partitioner* part);

} // namespace pq
#endif
