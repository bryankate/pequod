// -*- mode: c++ -*-
#ifndef PQTWITTER_HH
#define PQTWITTER_HH 1
#include <boost/random.hpp>
#include <utility>
#include <vector>
#include <iostream>
#include <stdint.h>
#include <tamer/tamer.hh>
#include <sys/resource.h>
#include "time.hh"
#include "json.hh"
#include "pqjoin.hh"
#include "pqserver.hh"
#include "twitter_client.hh"
namespace pq {
using tamer::event;
using tamer::preevent;

class TwitterPopulator {
  public:
    typedef boost::mt19937 generator_type;
    typedef boost::random_number_generator<boost::mt19937> rng_type;

    TwitterPopulator(const Json& param);

    inline uint32_t nusers() const;
    inline void set_nusers(uint32_t n);
    inline bool push() const;
    inline bool log() const;

    void create_subscriptions(generator_type& gen);
    void print_subscription_statistics(std::ostream& stream) const;
    inline const std::vector<std::pair<uint32_t, uint32_t> >& subscriptions() const;
    inline const uint32_t* begin_followers(uint32_t user) const;
    inline const uint32_t* end_followers(uint32_t user) const;

    inline std::pair<uint32_t, Str> random_post(generator_type& gen) const;

  private:
    uint32_t nusers_;
    bool push_;
    bool log_;
    uint32_t min_followers_;
    uint32_t min_subs_;
    uint32_t max_subs_;
    uint32_t max_followers_;
    double shape_;

    std::vector<std::pair<uint32_t, uint32_t> > subs_;
    std::vector<uint32_t> followers_;
    std::vector<uint32_t> follower_ptrs_;

    static const char tweet_data[];

    TwitterPopulator(const TwitterPopulator&) = delete;
    TwitterPopulator& operator=(const TwitterPopulator&) = delete;

    uint32_t* subscribe_probabilities(generator_type& gen);
};

template <typename S>
class TwitterRunner {
  public:
    TwitterRunner(S& server, TwitterPopulator& tp);

    tamed void populate();
    tamed void run();

  private:
    S& server_;
    TwitterPopulator& tp_;

    tamed void post(uint32_t u, uint32_t time, Str value, event<> e);
};

inline uint32_t TwitterPopulator::nusers() const {
    return nusers_;
}

inline void TwitterPopulator::set_nusers(uint32_t n) {
    nusers_ = n;
}

inline bool TwitterPopulator::push() const {
    return push_;
}

inline bool TwitterPopulator::log() const {
    return log_;
}

inline const std::vector<std::pair<uint32_t, uint32_t> >& TwitterPopulator::subscriptions() const {
    return subs_;
}

inline const uint32_t* TwitterPopulator::begin_followers(uint32_t user) const {
    return followers_.data() + follower_ptrs_[user];
}

inline const uint32_t* TwitterPopulator::end_followers(uint32_t user) const {
    return followers_.data() + follower_ptrs_[user + 1];
}

inline std::pair<uint32_t, Str> TwitterPopulator::random_post(generator_type& gen) const {
    return std::make_pair(1000000000U - gen() % 65536, Str(tweet_data, 140 - gen() % 140));
}

template <typename S>
inline TwitterRunner<S>::TwitterRunner(S& server, TwitterPopulator& tp)
    : server_(server), tp_(tp) {
}

tamed template <typename S>
void TwitterRunner<S>::post(uint32_t u, uint32_t time, Str value,
                            event<> e) {
    tvars { pq::FollowerRange fr; }
    twait {
        fr.first = tp_.begin_followers(u);
        fr.second = tp_.end_followers(u);
        server_.post(u, value, time, make_event(),
                     tp_.push() ? &fr : NULL);
    }
    e();
}

tamed template <typename S>
void TwitterRunner<S>::populate() {
    tvars { boost::mt19937 gen; }
    gen.seed(0);
    tp_.create_subscriptions(gen);

    twait {
        for (auto& x : tp_.subscriptions()) {
            server_.follow(x.first, x.second, make_event());
            if (tp_.log())
                printf("subscribe s|%05d|%05d\n", x.first, x.second);
        }
    }

#if 0
    for (uint32_t u = 0; u != tp_.nusers(); ++u)
        for (int p = 0; p != 10; ++p) {
            auto post = tp_.random_post(gen);
            post(u, post.first, post.second);
            if (p == 9 && u % 1000 == 0)
                fprintf(stderr, "%u/%u ", u, tp_.nusers());
        }
#endif

    tp_.print_subscription_statistics(std::cout);
}

tamed template <typename S>
void TwitterRunner<S>::run() {
    tvars {
        boost::mt19937 gen;
        boost::random_number_generator<boost::mt19937> rng(gen);
        struct rusage ru[2];
        uint32_t time = 1000000000;
        uint32_t nusers = this->tp_.nusers();
        uint32_t post_end_time = time + nusers * 5;
        uint32_t end_time = post_end_time + 1000000;
        uint32_t* load_times = new uint32_t[nusers];
        uint32_t npost = 0, nfull = 0, nupdate = 0, a, u, tx;
        size_t nread = 0;
        pq::RefreshResult refresh_result;
        Json stats;
        bool full;
    }
    gen.seed(13918);

    for (uint32_t i = 0; i != nusers; ++i)
        load_times[i] = 0;
    getrusage(RUSAGE_SELF, &ru[0]);

    while (time != end_time) {
        u = rng(nusers);
        a = rng(100);
        if (time < post_end_time || a < 2) {
            if (tp_.log())
                printf("%d: post p|%05d|%010d\n", time, u, time);
            twait { post(u, time, "?!?#*", make_event()); }
            ++npost;
        } else {
            tx = load_times[u];
            full = !tx || a < 3;
            ++(full ? nfull : nupdate);
            twait {
                server_.refresh(u, &load_times[u], full, time, make_event(refresh_result));
            }
            if (tp_.log()) {
                std::cout << time << ": refresh " << u << " since " << tx << "\n";
                String &r = refresh_result.second;
                int pos = 0, pos2;
                while ((pos2 = r.find_left('\254', pos)) >= 0) {
                    Str key(r.data() + pos, r.data() + pos2);
                    if ((pos = r.find_left('\255', pos2)) == -1)
                        pos = r.length();
                    Str value(r.data() + pos2 + 1, r.data() + pos);
                    std::cout << "  " << key << ": " << value << "\n";
                }
            }
            nread += refresh_result.first;
        }
        ++time;
    }

    getrusage(RUSAGE_SELF, &ru[1]);
    twait { server_.stats(make_event(stats)); }
    stats = Json().set("nposts", npost).set("nfull", nfull)
	.set("nupdate", nupdate).set("nposts_read", nread)
	.set("time", to_real(ru[1].ru_utime - ru[0].ru_utime))
        .merge(stats);
    std::cout << stats.unparse(Json::indent_depth(4)) << "\n";
    delete[] load_times;
}

} // namespace pq
#endif
