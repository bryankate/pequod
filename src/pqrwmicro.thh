#ifndef PQRWMICRO_HH
#define PQRWMICRO_HH 1

#include <tamer/tamer.hh>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/resource.h>
#define DO_PERF 0
#if DO_PERF
#include <sys/prctl.h>
#include <sys/wait.h>
#endif
#include "json.hh"
#include "time.hh"

namespace pq {

template <typename S>
class RwMicro {
  public:
    RwMicro(Json& param, S& server) 
        : prefresh_(param["prefresh"].as_i(10)), // percentage of refresh requests
          pactive_(param["pactive"].as_i(100)), // percentage of tweets being read
          nops_(param["nops"].as_i(100000)),
          nuser_(param["nusers"].as_i(1000)),
          nfollower_(param["nfollower"].as_i(100)), 
          server_(server),
          push_(param["push"].as_b(true)), j_(NULL),
          pprerefresh_(param["pprerefresh"].as_i(0)),
          client_push_(param["client_push"].as_b(false)) {
    }
    tamed inline void populate();
    tamed inline void run();
  private:
    tamed inline void post(uint32_t poster, size_t time, Str value, tamer::event<> e);

    int prefresh_;
    int pactive_;
    int nops_;
    int nuser_;
    int nfollower_;
    S& server_;
    bool push_;
    Join* j_;
    int pprerefresh_;
    bool client_push_;
};

tamed template <typename S>
void RwMicro<S>::post(uint32_t u, size_t time, Str value, tamer::event<> e) {
    tvars { 
        char buf[128];
        std::set<uint32_t> follower; 
    }
    twait { server_.post(u, time, value, make_event()); }
    if (client_push_) {
        twait { server_.get_follower(u, make_event(follower)); }
        twait {
            server_.prepare_push_post(u, time, value);
            for (auto& f : follower)
                server_.push_post(f, make_event());
        }
    }
    e();
}

tamed template <typename S>
void RwMicro<S>::populate() {
    tvars { size_t nread = 0, time = 1; }
    srandom(1328);
    twait {
        bool *b = new bool[nuser_];
        for (int u = 0; u < nuser_; ++u) {
            bzero(b, nuser_ * sizeof(*b));
            b[u] = true;
            for (int j = 0; j < nfollower_; ++j) {
                int follower;
                while (b[follower = (random() % nuser_)]);
                b[follower] = true;
                server_.subscribe(follower, u, make_event());
            }
        }
        delete[] b;
    }
    twait {
        int time = 1;
        for (int u = 0; u < nuser_; ++u)
            for (int i = 0; i < 10; ++i)
                post(u, ++time, String("She likes movie moby"), make_event());
    }
    twait { server_.initialize(client_push_, !push_, 0, 0, nuser_, !push_, make_event()); }
    if (pprerefresh_) {
        twait {
            for (int i = 0; i < nuser_ * pprerefresh_ / 100; ++i)
                server_.timeline_add_count(i, uint32_t(0), time, make_event(nread));
        }
    }
}

tamed template <typename S>
void RwMicro<S>::run() {
    tvars {
        int time = 100000000, npost = 0, nrefresh = 0;
        size_t nread = 0;
        int* loadtime = new int[this->nuser_];
        double trefresh = 0;
        struct rusage ru[2];
        struct timeval tv[2];
        Json old_stats, stats;
        tamer::gather_rendezvous gr;
        const int nu_active = this->nuser_ * this->pactive_ / 100;
    }
    srandom(18181);
    bzero(loadtime, sizeof(*loadtime) * nuser_);
#if DO_PERF
    // perf profiling
    {
        String me(getpid());
        pid_t pid = fork();
        if (!pid) {
            prctl(PR_SET_PDEATHSIG, SIGINT);
            execlp("perf", "perf", "record", "-g", "-p", me.c_str(), NULL);
            exit(0);
        }
    }
#endif
    twait { server_.stats(make_event(old_stats)); }
    gettimeofday(&tv[0], NULL);
    getrusage(RUSAGE_SELF, &ru[0]);
    for (int i = 0; i < nops_; ++i) {
        if (random() % 100 < prefresh_) {
            struct timeval optv[2];
            gettimeofday(&optv[0], NULL);
            int u = random() % nu_active;
            ++nrefresh;
            server_.timeline_add_count(u, loadtime[u] + 1, time, gr.make_event(nread));
            loadtime[u] = time;
            gettimeofday(&optv[1], NULL);
            trefresh += to_real(optv[1] - optv[0]);
        } else {
            int poster = random() % nu_active;
            post(poster, ++time, String("She likes movie moby"), gr.make_event());
            ++npost;
        }
    }
    twait(gr);
    getrusage(RUSAGE_SELF, &ru[1]);
    gettimeofday(&tv[1], NULL);
    twait { server_.stats(make_event(stats)); }
    if (stats.get("server_user_time")) {
        stats["server_user_time"] -= old_stats["server_user_time"];
        stats["server_system_time"] -= old_stats["server_system_time"];
    }
    stats = Json().set("inactive", 100 - pactive_)
        //.set("actual_post_read", nread * 100.0 / (std::max(npost, 1) * nfollower_))
        .set("expected_prefresh", prefresh_)
        .set("actual_prefresh", nrefresh * 100.0 / nops_)
        .set("nposts", npost)
        .set("total_ops", nops_)
	.set("nposts_read", nread)
        .set("nrefresh", nrefresh)
	.set("user_time", to_real(ru[1].ru_utime - ru[0].ru_utime))
        .set("system_time", to_real(ru[1].ru_stime - ru[0].ru_stime))
        .set("real_time", to_real(tv[1] - tv[0]))
        .set("refresh_time", trefresh)
        .merge(stats);
    std::cout << stats.unparse(Json::indent_depth(4)) << "\n";
    delete[] loadtime;
}

};

#endif
