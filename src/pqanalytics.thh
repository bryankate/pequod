// -*- mode: c++ -*-
#ifndef PQANALYTICS_HH
#define PQANALYTICS_HH

#include "pqserver.hh"
#include "json.hh"
#include "time.hh"
#include <sys/resource.h>
#include <boost/random.hpp>
#include <tamer/tamer.hh>
#include <map>

namespace pq {

// convert a base 10 timestamp (in seconds) to base 60 string
inline String to_base60(uint32_t base10, uint32_t width = 8) {
    std::string result;
    char buff[4];

    do {
        sprintf(buff, "%02u", base10 % 60);
        result.insert(0, buff, 2);
        base10 /= 60;
    } while(base10 > 0);

    if (result.size() < width)
        result.insert(0, width - result.size(), '0');

    assert(result.size() == width);
    return String(result);
}

template <typename S>
class AnalyticsRunner {
  public:
    typedef boost::mt19937 generator_type;

    AnalyticsRunner(S& server, const Json& param);
    tamed void safe_run();

  private:
    S& server_;
    Json param_;

    // parameters
    bool push_;
    bool proactive_;
    bool buffer_;
    uint32_t popduration_;
    uint32_t duration_;
    uint32_t pread_;

    // state
    uint32_t bytes_;

    tamed void populate(tamer::event<> done);
    tamed void run(tamer::event<> done);
    tamed void record_bps(uint32_t time, uint32_t bytes, tamer::event<> done);
};


template <typename S>
class AnalyticsShim {
  public:
    AnalyticsShim(S& server);

    tamed void initialize(bool push, bool prevalidate, tamer::event<> done);
    template <typename R>
    inline void record_bps(uint32_t time, uint32_t bytes, tamer::preevent<R> done);
    template <typename R>
    inline void record_bpm(uint32_t time, uint32_t bytes, tamer::preevent<R> done);
    template <typename R>
    inline void bpm_add_count(uint32_t start_time, uint32_t now, tamer::preevent<R, size_t> e);
    template <typename R>
    inline void pace(tamer::preevent<R> e);
    template <typename R>
    inline void stats(tamer::preevent<R, Json> e);

  private:
    S& server_;
};

template <typename S>
AnalyticsShim<S>::AnalyticsShim(S& server)
    : server_(server) {
}

tamed template <typename S>
void AnalyticsShim<S>::initialize(bool push, bool prevalidate, tamer::event<> done) {
    tvars {
        Json j;
        typename S::scan_result scan_result;
    }

    if (push)
        done();
    else {
        twait {
            server_.add_join("Bpm|", "Bpm}",
                             "Bpm|<hour><min> = "
                             "sum Bps|<hour><min><sec> "
                             "where hour:4, min:2, sec:2",
                             make_event(j));
        }

        if (j["message"])
            std::cerr << "installing join: " << j << std::endl;

        if (prevalidate)
            twait { server_.scan(String("Bpm|"), String("Bpm}"), make_event(scan_result)); }

        done();
    }
}

template <typename S> template <typename R>
inline void AnalyticsShim<S>::record_bps(uint32_t time, uint32_t bytes, tamer::preevent<R> done) {
    server_.insert(String("Bps|") + to_base60(time), String(bytes), done);
}

template <typename S> template <typename R>
inline void AnalyticsShim<S>::record_bpm(uint32_t time, uint32_t bytes, tamer::preevent<R> done) {
    server_.insert(String("Bpm|") + to_base60(time).substring(0,6), String(bytes), done);
}

template <typename S> template <typename R>
inline void AnalyticsShim<S>::bpm_add_count(uint32_t start_time, uint32_t now,
                                            tamer::preevent<R, size_t> done) {
    server_.add_count(String("Bpm|") + to_base60(start_time).substring(0,8),
                      String("Bpm|") + to_base60(now), done);
}

template <typename S> template <typename R>
inline void AnalyticsShim<S>::pace(tamer::preevent<R> done) {
    server_.pace(done);
}

template <typename S> template <typename R>
inline void AnalyticsShim<S>::stats(tamer::preevent<R, Json> done) {
    server_.stats(done);
}

template <typename S>
AnalyticsRunner<S>::AnalyticsRunner(S& server, const Json& param)
    : server_(server), param_(param),
      push_(param["push"].as_b(false)),
      proactive_(param["proactive"].as_b(false)),
      buffer_(param["buffer"].as_b(false)),
      popduration_(param["popduration"].as_i(86400)),
      duration_(param["duration"].as_i(1728000)),
      pread_(param["pread"].as_i(1)), bytes_(0) {
}

tamed template <typename S>
void AnalyticsRunner<S>::record_bps(uint32_t time, uint32_t bytes, tamer::event<> done) {
    tvars {
        uint32_t flushbytes = 0;
        bool flush = false;
        generator_type gen;
    }

    if (time && time % 60 == 0) {
        flush = true;
        flushbytes = bytes_;
        bytes_ = 0;
    }

    twait {
        server_.record_bps(time, bytes, make_event());
        bytes_ += bytes;

        if (!buffer_ && push_)
            server_.record_bpm(time, bytes_, make_event());
        else if (flush && push_)
            server_.record_bpm(time - 1, flushbytes, make_event());
    }

    done();
}

tamed template <typename S>
void AnalyticsRunner<S>::safe_run() {
    twait { this->populate(make_event()); }
    twait { this->run(make_event()); }
}

tamed template <typename S>
void AnalyticsRunner<S>::populate(tamer::event<> done) {
    tvars {
        uint32_t time;
        generator_type gen;
        tamer::gather_rendezvous gr;
    }
    gen.seed(111982);

    for (time = 0; time < popduration_; ++time) {
        record_bps(time, gen() % 1048576, gr.make_event());
        twait { server_.pace(make_event()); }
    }
    twait(gr);
    twait { server_.initialize(push_, proactive_, make_event()); }

    done();
}

tamed template <typename S>
void AnalyticsRunner<S>::run(tamer::event<> done) {
    tvars {
        struct rusage ru[2];
        struct timeval tv[2];
        uint32_t nquery = 0;
        size_t nread = 0;
        uint32_t time;
        generator_type gen;
        Json old_stats, stats;
        tamer::gather_rendezvous gr;
    }
    gen.seed(112181);

    twait { server_.stats(make_event(old_stats)); }
    getrusage(RUSAGE_SELF, &ru[0]);
    gettimeofday(&tv[0], 0);

    for (time = popduration_; time != popduration_ + duration_; ++time) {
        record_bps(time, gen() % 1048576, gr.make_event());

        if (gen() % 100 < pread_) {
            ++nquery;
            server_.bpm_add_count(time - 86400, time, gr.make_event(nread));
        }

        twait { server_.pace(make_event()); }
    }
    twait(gr);

    getrusage(RUSAGE_SELF, &ru[1]);
    gettimeofday(&tv[1], 0);
    twait { server_.stats(make_event(stats)); }

    if (stats.get("server_user_time")) {
        stats["server_user_time"] -= old_stats["server_user_time"];
        stats["server_system_time"] -= old_stats["server_system_time"];
    }

    stats = stats.set("nquery", nquery)
                 .set("npoints_read", nread)
                 .set("system_time", to_real(ru[1].ru_stime - ru[0].ru_stime))
                 .set("user_time", to_real(ru[1].ru_utime - ru[0].ru_utime))
                 .set("real_time", to_real(tv[1] - tv[0]));
    std::cout << stats.unparse(Json::indent_depth(4)) << std::endl;

    done();
}

tamed void run_analytics_remote(const Json& tp, int client_port);

}
#endif
