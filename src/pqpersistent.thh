#ifndef PQ_PERSISTENT_HH
#define PQ_PERSISTENT_HH
#include "str.hh"
#include "string.hh"
#include "readerwriterqueue.h"
#include <tamer/tamer.hh>
#include <boost/thread.hpp>
#include <atomic>

namespace pq {
class Server;

class PersistentStore {
  public:
    typedef std::pair<String,String> Result;
    typedef std::vector<Result> ResultSet;

    virtual ~PersistentStore() { }

    virtual int32_t put(Str key, Str value) = 0;
    virtual void erase(Str key) = 0;
    virtual String get(Str key) = 0;
    virtual void scan(Str first, Str last, ResultSet& results) = 0;
    virtual void run_monitor(Server& server) = 0;
};

class PersistentOp {
  public:
    virtual ~PersistentOp() { }
    virtual void operator()(PersistentStore*) = 0;
};

class PersistentRead : public PersistentOp {
  public:
    PersistentRead(Str first, Str last, PersistentStore::ResultSet& rs);

    virtual void operator()(PersistentStore*);
    void set_trigger(tamer::event<> t);

  private:
    PersistentStore::ResultSet& rs_;
    tamer::event<> tev_;
    String first_;
    String last_;
};

class PersistentWrite : public PersistentOp {
  public:
    PersistentWrite(Str key, Str value);
    virtual void operator()(PersistentStore*);

  private:
    String key_;
    String value_;
};

class PersistentErase : public PersistentOp {
  public:
    PersistentErase(Str key);
    virtual void operator()(PersistentStore*);

  private:
    String key_;
};

class PersistentFlush : public PersistentOp {
  public:
    PersistentFlush(std::atomic<bool>& waiting, boost::condition_variable& cond);
    virtual void operator()(PersistentStore*);

  private:
    std::atomic<bool>& waiting_;
    boost::condition_variable& cond_;
};

class PersistentStoreThread {
  public:
    PersistentStoreThread(PersistentStore* store);
    ~PersistentStoreThread();

    void enqueue(PersistentOp* op);
    void flush();
    void run();

  private:
    PersistentStore* store_;
    boost::thread worker_;
    boost::mutex mu_;
    boost::condition_variable cond_;
    moodycamel::ReaderWriterQueue<PersistentOp*> pending_;
    std::atomic<bool> running_;
};

}

#if HAVE_DB_CXX_H
#include <db_cxx.h>

class BerkeleyDBStore : public pq::PersistentStore {

  public:
    BerkeleyDBStore(std::string eH = "./db/localEnv",
                    std::string dbN = "pequod.db",
                    uint32_t e_flags = BerkeleyDBStore::env_flags_,
                    uint32_t d_flags = BerkeleyDBStore::db_flags_);
    ~BerkeleyDBStore();

    virtual int32_t put(Str, Str);
    virtual void erase(Str);
    virtual String get(Str);
    virtual void scan(Str, Str, pq::PersistentStore::ResultSet&);
    virtual void run_monitor(pq::Server& server);

  private:
    static const uint32_t env_flags_ = DB_CREATE | DB_INIT_MPOOL;
    static const uint32_t db_flags_ = DB_CREATE;
    static const uint32_t cursor_flags_ = DB_CURSOR_BULK;
    std::string env_home_, db_name_;
    DbEnv *env_;
    Db *dbh_;

    void init(uint32_t, uint32_t);
};
#endif


#if HAVE_PQXX_PQXX
#include "pqxx/pqxx"
#include "pqxx/connection"
#include "pqxx/result"
#include "pqxx/transaction"

class PostgresStore : public pq::PersistentStore {
  public:
    PostgresStore(String db = "pequod", String host = "127.0.0.1", uint32_t port = 5432);
    ~PostgresStore();

    virtual int32_t put(Str, Str);
    virtual void erase(Str);
    virtual String get(Str);
    virtual void scan(Str, Str, pq::PersistentStore::ResultSet&);
    virtual void run_monitor(pq::Server& server);

  private:
    String dbname_;
    String host_;
    uint32_t port_;
    pqxx::connection* dbh_;
    pqxx::connection* monitor_;

    void init();
    String connection_string() const;

    tamed void monitor_db(pq::Server& server);
};

class PostgresListener : public pqxx::notification_receiver {
  public:
    enum { pg_update = 0, pg_delete };

    PostgresListener(pqxx::connection_base& conn, const std::string& channel, pq::Server& server);
    virtual void operator()(const std::string& payload, int32_t);

  private:
    pq::Server& server_;
};

#endif

#endif
