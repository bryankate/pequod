#ifndef PQMULTICLIENT_HH_
#define PQMULTICLIENT_HH_

#include "pqremoteclient.hh"
#include "hosts.hh"
#include "partitioner.hh"
#include "sock_helper.hh"
#include <vector>
#include <iostream>
#include <tamer/tamer.hh>
#if HAVE_PQXX_NOTIFICATION
#include "pqxx/pqxx"
#endif

namespace pq {

// todo: make DB client templated
class MultiClient {
  public:
    MultiClient(const Hosts* hosts, const Hosts* dbhosts,
                const Partitioner* part, int colocateCacheServer);
    ~MultiClient();

    tamed void connect(tamer::event<> done);
    tamed void restart(tamer::event<> done);
    inline void clear();

    typedef RemoteClient::iterator iterator;
    typedef RemoteClient::scan_result scan_result;

    tamed void add_join(const String& first, const String& last,
                        const String& joinspec, event<Json> e);

    tamed void get(const String& key, event<String> e);
    tamed void insert(const String& key, const String& value, event<> e);
    tamed void erase(const String& key, event<> e);

    tamed void insert_db(const String& key, const String& value, event<> e);
    tamed void erase_db(const String& key, event<> e);

    tamed void count(const String& first, const String& last,
                     event<size_t> e);
    tamed void add_count(const String& first, const String& last,
                         event<size_t> e);
    tamed void scan(const String& first, const String& last,
                    event<scan_result> e);

    tamed void stats(event<Json> e);
    tamed void control(const Json& cmd, event<Json> e);

    tamed void pace(tamer::event<> done);

  private:
    inline RemoteClient* cache_for(const String &key) const;
#if HAVE_PQXX_NOTIFICATION
    inline pqxx::connection* backend_for(const String &key) const;
#endif

    const Hosts* hosts_;
    const Hosts* dbhosts_;
    const Partitioner* part_;
    std::vector<RemoteClient*> clients_;
    RemoteClient* localNode_;
    int colocateCacheServer_;
#if HAVE_PQXX_NOTIFICATION
    std::vector<pqxx::connection*> dbclients_;
#endif
};

inline void MultiClient::clear() {
    for (auto &c : clients_)
        delete c;
    clients_.clear();
    localNode_ = nullptr;

#if HAVE_PQXX_NOTIFICATION
    for (auto &c : dbclients_)
        delete c;
    dbclients_.clear();
#endif
}

#if HAVE_PQXX_NOTIFICATION
inline pqxx::connection* MultiClient::backend_for(const String &key) const {
    int32_t owner = part_->owner(key);
    assert(owner >= 0 && owner < (int32_t)dbclients_.size() && "Make sure the partition function is correct.");
    return dbclients_[owner];
}
#endif

inline RemoteClient* MultiClient::cache_for(const String &key) const {
    if (colocateCacheServer_ >= 0)
        return localNode_;
    else {
        int owner = part_->owner(key);
        assert(owner >= 0 && owner < (int32_t)clients_.size() && "Make sure the partition function is correct.");
        return clients_[owner];
    }
}

}

#endif
