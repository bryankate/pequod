#ifndef HASHCLIENT_HH
#define HASHCLIENT_HH
#if HAVE_LIBMEMCACHED_MEMCACHED_HPP
#include <libmemcached/memcached.hpp>
#endif
#include <tamer/tamer.hh>
#include <unordered_set>
#include "str.hh"
#include "hashtable.hh"
#include "string.hh"
#include "redisclient.hh"
#include "redisfd.hh"
#include "pqclient.hh"
#include "check.hh"

namespace pq {

#if HAVE_LIBMEMCACHED_MEMCACHED_HPP
class MemcachedClient {
  public:
    MemcachedClient() {
        const char *config = "--SERVER=localhost --BINARY-PROTOCOL";
        c_ = ::memcached(config, strlen(config));
        mandatory_assert(c_);
        expire_at_ = ::time(NULL) + 20 * 60 * 60; // never expire
    }
    void set(const Str k, const Str v, tamer::event<> e) {
        auto r = memcached_set(c_, k.data(), k.length(),
                               v.data(), v.length(), expire_at_, 0);
        check_error(r);
        e();
    }
    void append(const Str k, const Str v, tamer::event<> e) {
        auto r = memcached_append(c_, k.data(), k.length(),
                                  v.data(), v.length(), expire_at_, 0);
        if (r == MEMCACHED_NOTSTORED)
            set(k, v, e);
        else {
            check_error(r);
            e();
        }
    }
    void get(const Str okey, int32_t offset, tamer::event<String> e) {
        String k(okey);
        k += String("@");
        k += String(offset);
        uint32_t flags;
        memcached_return_t error;
        size_t value_length;
        const char *v = memcached_get(c_, k.data(), k.length(), &value_length, &flags, 
                                      &error);
        if (error != MEMCACHED_SUCCESS)
            e(String());
        else
            e(String(v, value_length));
        delete v;
    }
    void done_get(String) {
    }
    void increment(const Str, tamer::event<> e) {
        mandatory_assert(0, "unimplemented: need to change the server side");
        e();
    }
    void pace(tamer::event<> done) {
        done();
    }
  private:
    void check_error(memcached_return_t r) {
        if (r != MEMCACHED_SUCCESS) {
            std::cerr << memcached_strerror(NULL, r) << std::endl;
            mandatory_assert(0);
        }
    }
    memcached_st *c_;
    time_t expire_at_;
};
#endif

class RedisfdHashClient {
  public:
    RedisfdHashClient(tamer::fd fd) : fd_(fd) {}
    void get(Str k, tamer::event<String> e);
    void get(Str k, int begin, tamer::event<String> e) {
        getrange(k, begin, -1, e);
    }
    void getrange(Str k, int begin, int end, tamer::event<String> e);
    tamed void set(Str k, Str v, tamer::event<> e);
    tamed void append(Str k, Str v, tamer::event<> e);
    void done_get(String) {
    }
    tamed void increment(Str k, tamer::event<> e);
    void pace(tamer::event<> done);
  private:
    redis_fd fd_;
};

class BuiltinHashClient {
  public:
    BuiltinHashClient() {
        h_.rehash(2000000);
    }
    void set(const Str k, const Str v, tamer::event<> e) {
        h_[k] = v;
        e();
    }
    void append(const Str k, const Str v, tamer::event<> e) {
        auto& ev = h_[k];
        ev.append(v);
        e();
    }
    void get(const Str k, int32_t offset, tamer::event<String> e) {
        auto it = h_.find(k);
        if (it == h_.end())
            e(String());
        else {
            mandatory_assert(it->second.length() >= offset);
            e(String(it->second.data() + offset, it->second.length() - offset));
        }
    }
    void done_get(String) {
    }
    void increment(const Str k, tamer::event<> e) {
        auto& ev = h_[k];
        if (ev.empty())
            ev = String(1);
        else
            ev = String(ev.to_i() + 1);
        e();
    }
    void pace(tamer::event<> done) {
        done();
    }
  private:
    HashTable<String, String> h_;
};


template <typename S>
class TwitterHashShim {
  public:
    TwitterHashShim(S& server);

    tamed void get_follower(uint32_t poster, tamer::event<std::vector<uint32_t> > e);
    inline void add_follower(uint32_t subscriber, uint32_t poster, tamer::event<> e);

    inline void subscribe(uint32_t subscriber, uint32_t poster, tamer::event<> e);
    template <typename R>
    inline void mark_celebrity(uint32_t poster, tamer::preevent<R> e);
    inline void post(uint32_t poster, uint32_t time, Str value, tamer::event<> e);
    inline void initialize(bool client_push, bool server_pull, uint32_t celebrity,
                           int celebrity_type, uint32_t, bool pure_server_pull, tamer::event<> e);
    inline void prepare_push_post(uint32_t poster, uint32_t time, Str value);
    inline void push_post(uint32_t subscriber, tamer::event<> e);
    typedef DirectClient::scan_result scan_result;
    template <typename R>
    inline void timeline_scan(uint32_t subscriber, uint32_t start_time, uint32_t now, tamer::preevent<R, scan_result> e);
    tamed void timeline_add_count(uint32_t subscriber, uint32_t start_time, uint32_t now, tamer::event<size_t> e);
    void timeline_scan_add_count(uint32_t subscriber, uint32_t start_time, uint32_t now, tamer::event<size_t> e);
    void timeline_set_initial_count(uint32_t subscriber, uint32_t start_time, uint32_t now, tamer::event<size_t> e);

    template <typename R>
    inline void pace(tamer::preevent<R> e);
    template <typename R>
    inline void stats(tamer::preevent<R, Json> e);
    template <typename R>
    inline void control(const Json& cmd, tamer::preevent<R, Json> e);

  private:
    S& server_;
    char buf_[128];
    int buflen_;
    struct tlstatus {
        uint32_t time;
        size_t pos;
        tlstatus() : time(0), pos(0) {}
    };
    std::vector<tlstatus> last_refresh_;
};

template <typename S>
TwitterHashShim<S>::TwitterHashShim(S& server)
    : server_(server) {
}

tamed template <typename S>
inline void TwitterHashShim<S>::get_follower(uint32_t poster, tamer::event<std::vector<uint32_t> > e) {
    tvars { 
        String v; 
        std::unordered_set<uint32_t> follower;
    }
    sprintf(buf_, "f|%05u", poster);
    twait {
        server_.get(Str(buf_, 7), 0, make_event(v));
    }
    CHECK_EQ(v.length() % 5, 0);
    for (int i = 0; i < v.length(); i+=5)
        follower.insert(String(v.data() + i, v.data() + i + 5).to_i());
    for (auto& f: follower)
        e.result_pointer()->push_back(f);
    server_.done_get(v);
    e.unblock();
}

template <typename S>
inline void TwitterHashShim<S>::add_follower(uint32_t subscriber, uint32_t poster, tamer::event<> done) {
    sprintf(buf_, "f|%05u %05u", poster, subscriber);
    server_.append(Str(buf_, 7), Str(buf_ + 8, 5), done);
}

template <typename S>
inline void TwitterHashShim<S>::initialize(bool client_push, bool server_pull, uint32_t celebrity,
                                           int celebrity_type, uint32_t, bool pure_server_pull, tamer::event<> done) {
    mandatory_assert(client_push && !server_pull && !celebrity && !celebrity_type && !pure_server_pull);
    done();
}

template <typename S>
inline void TwitterHashShim<S>::subscribe(uint32_t subscriber, uint32_t poster, tamer::event<> done) {
    sprintf(buf_, "s|%05u %05u", subscriber, poster);
    server_.append(Str(buf_, 7), Str(buf_ + 8, 5), done);
}

template <typename S> template <typename R>
inline void TwitterHashShim<S>::mark_celebrity(uint32_t poster, tamer::preevent<R> done) {
    (void) poster;
    done();
}

template <typename S>
inline void TwitterHashShim<S>::post(uint32_t poster, uint32_t time, Str value, tamer::event<> done) {
    sprintf(buf_, "p|%05u|%010u", poster, time);
    server_.set(Str(buf_, 18), value, done);
}

template <typename S>
inline void TwitterHashShim<S>::prepare_push_post(uint32_t poster, uint32_t time, Str value) {
    sprintf(buf_, "t|%05u %05u|%010u\254", 0, poster, time);
    assert(sizeof(buf_) >= size_t(value.length()) + 26);
    memcpy(buf_ + 25, value.data(), value.length());
    buflen_ = 25 + value.length();
}

template <typename S>
inline void TwitterHashShim<S>::push_post(uint32_t subscriber, tamer::event<> done) {
    sprintf(buf_ + 2, "%05u", subscriber);
    server_.append(Str(buf_, 7), Str(buf_ + 8, buflen_ - 8), done);
}

template <typename S>
inline void TwitterHashShim<S>::timeline_scan_add_count(uint32_t subscriber, uint32_t start_time, uint32_t now, tamer::event<size_t> done) {
    timeline_add_count(subscriber, start_time, now, done);
}

template <typename S> template <typename R>
inline void TwitterHashShim<S>::timeline_scan(uint32_t subscriber, uint32_t start_time, uint32_t, tamer::preevent<R, scan_result> done) {
    (void) subscriber, (void) start_time;
    assert(0);
    done.unblock();
}

tamed template <typename S>
inline void TwitterHashShim<S>::timeline_add_count(uint32_t subscriber, uint32_t start_time, uint32_t now, tamer::event<size_t> done) {
    tvars { 
       String v;
       tlstatus* tls;
       size_t oldpos;
    }
    if (last_refresh_.size() <= subscriber)
        last_refresh_.resize(subscriber + 1);
    tls = &last_refresh_[subscriber];
    if (tls->time > start_time)
        tls->pos = 0;
    tls->time = now;
    sprintf(buf_, "t|%05u", subscriber);
    oldpos = tls->pos;
    twait { server_.get(Str(buf_, 7), int(oldpos), make_event(v)); }
    tls = &last_refresh_[subscriber];
    if (tls->pos == oldpos)
        tls->pos += v.length();
    size_t n = 0;
    for (int pos = 0; (pos = v.find_left('\254', pos)) != -1; ++pos) {
        const char *p;
        for (p = v.data() + pos; *p != '|'; --p);
        if (uint32_t(atoi(p + 1)) >= start_time)
            ++n;
    }
    done(done.result() + n);
    server_.done_get(v);
}

template <typename S>
void TwitterHashShim<S>::timeline_set_initial_count(uint32_t subscriber, uint32_t start_time, uint32_t now, tamer::event<size_t> done) {
    timeline_add_count(subscriber, start_time, now, done);
}

template <typename S> template <typename R>
inline void TwitterHashShim<S>::pace(tamer::preevent<R> done) {
    server_.pace(done);
}

template <typename S> template <typename R>
inline void TwitterHashShim<S>::stats(tamer::preevent<R, Json> done) {
    done(Json());
}

template <typename S> template <typename R>
inline void TwitterHashShim<S>::control(const Json& cmd, tamer::preevent<R, Json> done) {
    (void)cmd;
    done(Json());
}

} // namespace pq
#endif
