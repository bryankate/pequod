#ifndef HASHCLIENT_HH
#define HASHCLIENT_HH
#if HAVE_LIBMEMCACHED_MEMCACHED_HPP
#include <libmemcached/memcached.hpp>
#endif
#if HAVE_HIREDIS
#include <hiredis/hiredis.h>
#include <hiredis/async.h>
#include <hiredis/adapters/libev.h>
#endif
#include <tamer/tamer.hh>
#include <unordered_set>
#include "str.hh"
#include "hashtable.hh"
#include "string.hh"

namespace pq {

#if HAVE_LIBMEMCACHED_MEMCACHED_HPP
class MemcachedClient {
  public:
    MemcachedClient() {
        const char *config = "--SERVER=localhost --BINARY-PROTOCOL";
        c_ = ::memcached(config, strlen(config));
        mandatory_assert(c_);
        expire_at_ = ::time(NULL) + 20 * 60 * 60; // never expire
    }
    void set(const Str k, const Str v) {
        auto r = memcached_set(c_, k.data(), k.length(),
                               v.data(), v.length(), expire_at_, 0);
        check_error(r);
    }
    void append(const Str k, const Str v) {
        auto r = memcached_append(c_, k.data(), k.length(),
                                  v.data(), v.length(), expire_at_, 0);
        if (r == MEMCACHED_NOTSTORED)
            set(k, v);
        else
            check_error(r);
    }
    void get(const Str okey, int32_t offset, tamer::event<Str> e) {
        String k(okey);
        k += String("@");
        k += String(offset);
        uint32_t flags;
        memcached_return_t error;
        size_t value_length;
        const char *v = memcached_get(c_, k.data(), k.length(), &value_length, &flags, 
                                      &error);
        if (error != MEMCACHED_SUCCESS)
            e(Str());
        else
            e(Str(v, value_length));
    }
    void done_get(Str v) {
        if (v.s)
            delete v.s;
    }
    void increment(const Str) {
        mandatory_assert(0, "unimplemented: need to change the server side");
    }
  private:
    void check_error(memcached_return_t r) {
        if (r != MEMCACHED_SUCCESS) {
            std::cerr << memcached_strerror(NULL, r) << std::endl;
            mandatory_assert(0);
        }
    }
    memcached_st *c_;
    time_t expire_at_;
};
#endif

#if HAVE_HIREDIS
class RedisClient {
  public:
    struct RedisArg {
        RedisClient *c_;
        tamer::event<Str> e_;
        explicit RedisArg(RedisClient* c) : c_(c) {}
        RedisArg(RedisClient* c, tamer::event<Str> e) : c_(c), e_(e) {}
    };

    RedisClient() : nsent_(0), ndone_(0), w_(100) {
        c_ = redisAsyncConnect("localhost", 6379);
        redisLibevAttach(EV_DEFAULT_ c_);
    }
    void get(const Str k, int32_t offset, tamer::event<Str> e) {
        doone(getcb, new RedisArg(this, e), "GETRANGE %b %d -1", k.data(), k.length(), offset);
    }
    void set(const Str k, const Str v) {
        doone(checkok, new RedisArg(this), "SET %b %b", k.data(), k.length(), v.data(), v.length());
    }
    void append(const Str k, const Str v) {
        doone(checkok, new RedisArg(this), "APPEND %b %b", k.data(), k.length(), v.data(), v.length());
    }
    void done_get(Str) {
    }
  private:
    static void checkok(redisAsyncContext* c, void* r, void* privdata) {
        mandatory_assert(c && r);
        redisReply* reply = reinterpret_cast<redisReply*>(r);
        mandatory_assert(reply->type == REDIS_REPLY_STATUS && reply->integer == REDIS_OK);
        RedisArg* ra = reinterpret_cast<RedisArg *>(privdata);
        ra->c_->onedone();
        delete ra;
    }
    static void getcb(redisAsyncContext* c, void* r, void* privdata) {
        mandatory_assert(c && r);
        redisReply* reply = reinterpret_cast<redisReply*>(r);
        mandatory_assert(reply->type == REDIS_REPLY_STRING);
        RedisArg* ra = reinterpret_cast<RedisArg *>(privdata);
        ra->e_(Str(reply->str, reply->len));
        ra->c_->onedone();
        delete ra;
    }
    void onedone() {
	++ndone_;
	if (nsent_ - ndone_ <= w_ / 2)
            ev_unloop (EV_DEFAULT_ EVUNLOOP_ONE);
    }
    void doone(redisCallbackFn *fn, void *privdata, const char *format, ...) {
	if (nsent_ - ndone_ > w_)
	    ev_loop(EV_DEFAULT_ 0);
        ++nsent_;
	va_list ap;
        va_start(ap, format);
        redisvAsyncCommand(c_, fn, privdata, format, ap); 
	va_end(ap);
    }
    int nsent_;
    int ndone_;
    int w_;
    redisAsyncContext *c_;
};
#endif

class BuiltinHashClient {
  public:
    BuiltinHashClient() {
        h_.rehash(2000000);
    }
    void set(const Str k, const Str v) {
        h_[k] = v;
    }
    void append(const Str k, const Str v) {
        auto& ev = h_[k];
        ev.append(v);
    }
    void get(const Str k, int32_t offset, tamer::event<Str> e) {
        auto it = h_.find(k);
        if (it == h_.end())
            e(Str());
        else {
            mandatory_assert(it->second.length() >= offset);
            e(Str(it->second.data() + offset, it->second.length() - offset));
        }
    }
    void done_get(Str) {
    }
    void increment(const Str k) {
        auto& ev = h_[k];
        if (ev.empty())
            ev = String(1);
        else
            ev = String(ev.to_i() + 1);
    }
  private:
    HashTable<String, String> h_;
};


template <typename S>
class TwitterHashShim {
  public:
    TwitterHashShim(S& server);

    tamed void get_follower(uint32_t poster, tamer::event<std::vector<uint32_t> > e);
    inline void add_follower(uint32_t subscriber, uint32_t poster, tamer::event<> e);

    template <typename R>
    inline void subscribe(uint32_t subscriber, uint32_t poster, tamer::preevent<R> e);
    template <typename R>
    inline void mark_celebrity(uint32_t poster, tamer::preevent<R> e);
    template <typename R>
    inline void post(uint32_t poster, uint32_t time, Str value, tamer::preevent<R> e);
    inline void initialize(bool client_push, bool server_pull, uint32_t celebrity,
                           int celebrity_type, uint32_t, bool pure_server_pull, tamer::event<> e);
    inline void prepare_push_post(uint32_t poster, uint32_t time, Str value);
    template <typename R>
    inline void push_post(uint32_t subscriber, tamer::preevent<R> e);
    typedef DirectClient::scan_result scan_result;
    template <typename R>
    inline void timeline_scan(uint32_t subscriber, uint32_t start_time, uint32_t now, tamer::preevent<R, scan_result> e);
    tamed void timeline_add_count(uint32_t subscriber, uint32_t start_time, uint32_t now, tamer::event<size_t> e);
    template <typename R>
    inline void pace(tamer::preevent<R> e);
    template <typename R>
    inline void stats(tamer::preevent<R, Json> e);

  private:
    S& server_;
    char buf_[128];
    int buflen_;
    struct tlstatus {
        uint32_t time;
        size_t pos;
        tlstatus() : time(0), pos(0) {}
    };
    std::vector<tlstatus> last_refresh_;
};

template <typename S>
TwitterHashShim<S>::TwitterHashShim(S& server)
    : server_(server) {
}

tamed template <typename S>
inline void TwitterHashShim<S>::get_follower(uint32_t poster, tamer::event<std::vector<uint32_t> > e) {
    tvars { Str v; }
    sprintf(buf_, "f|%05u", poster);
    twait {
        server_.get(Str(buf_, 7), 0, make_event(v));
    }
    CHECK_EQ(v.length() % 5, 0);
    std::unordered_set<uint32_t> follower;
    for (int i = 0; i < v.length(); i+=5)
        follower.insert(String(v.data() + i, v.data() + i + 5).to_i());
    for (auto& f: follower)
        e.result_pointer()->push_back(f);
    server_.done_get(v);
    e.unblock();
}

template <typename S>
inline void TwitterHashShim<S>::add_follower(uint32_t subscriber, uint32_t poster, tamer::event<> done) {
    sprintf(buf_, "f|%05u %05u", poster, subscriber);
    server_.append(Str(buf_, 7), Str(buf_ + 8, 5));
    done();
}

template <typename S>
inline void TwitterHashShim<S>::initialize(bool client_push, bool server_pull, uint32_t celebrity,
                                           int celebrity_type, uint32_t, bool pure_server_pull, tamer::event<> done) {
    mandatory_assert(client_push && !server_pull && !celebrity && !celebrity_type && !pure_server_pull);
    done();
}

template <typename S> template <typename R>
inline void TwitterHashShim<S>::subscribe(uint32_t subscriber, uint32_t poster, tamer::preevent<R> done) {
    sprintf(buf_, "s|%05u %05u", subscriber, poster);
    server_.append(Str(buf_, 7), Str(buf_ + 8, 5));
    done();
}

template <typename S> template <typename R>
inline void TwitterHashShim<S>::mark_celebrity(uint32_t poster, tamer::preevent<R> done) {
    (void) poster;
    done();
}

template <typename S> template <typename R>
inline void TwitterHashShim<S>::post(uint32_t poster, uint32_t time, Str value, tamer::preevent<R> done) {
    sprintf(buf_, "p|%05u|%010u", poster, time);
    server_.set(Str(buf_, 18), value);
    done();
}

template <typename S>
inline void TwitterHashShim<S>::prepare_push_post(uint32_t poster, uint32_t time, Str value) {
    sprintf(buf_, "t|%05u %05u|%010u\254", 0, poster, time);
    assert(sizeof(buf_) >= size_t(value.length()) + 26);
    memcpy(buf_ + 25, value.data(), value.length());
    buflen_ = 25 + value.length();
}

template <typename S> template <typename R>
inline void TwitterHashShim<S>::push_post(uint32_t subscriber, tamer::preevent<R> done) {
    sprintf(buf_ + 2, "%05u", subscriber);
    server_.append(Str(buf_, 7), Str(buf_ + 8, buflen_ - 8));
    done();
}

template <typename S> template <typename R>
inline void TwitterHashShim<S>::timeline_scan(uint32_t subscriber, uint32_t start_time, uint32_t, tamer::preevent<R, scan_result> done) {
    (void) subscriber, (void) start_time;
    assert(0);
    done.unblock();
}

tamed template <typename S>
inline void TwitterHashShim<S>::timeline_add_count(uint32_t subscriber, uint32_t start_time, uint32_t now, tamer::event<size_t> done) {
    tvars { 
       Str v;
       tlstatus* tls;
    }
    if (last_refresh_.size() <= subscriber)
        last_refresh_.resize(subscriber + 1);
    tls = &last_refresh_[subscriber];
    if (tls->time > start_time)
        tls->pos = 0;
    tls->time = now;
    sprintf(buf_, "t|%05u", subscriber);
    twait { server_.get(Str(buf_, 7), tls->pos, make_event(v)); }
    tls->pos += v.length();
    size_t n = 0;
    for (int pos = 0; (pos = v.find_left('\254', pos)) != -1; ++pos) {
        const char *p;
        for (p = v.data() + pos; *p != '|'; --p);
        if (uint32_t(atoi(p + 1)) >= start_time)
            ++n;
    }
    done(done.result() + n);
    server_.done_get(v);
}

template <typename S> template <typename R>
inline void TwitterHashShim<S>::pace(tamer::preevent<R> done) {
    done();
}

template <typename S> template <typename R>
inline void TwitterHashShim<S>::stats(tamer::preevent<R, Json> done) {
    done(Json());
}

} // namespace pq
#endif
